{"version":3,"file":"GenerateTextureSystem.mjs","sources":["../../src/renderTexture/GenerateTextureSystem.ts"],"sourcesContent":["import { extensions, ExtensionType } from '@pixi/extensions';\nimport { Matrix, Rectangle, Transform } from '@pixi/math';\nimport { RenderTexture } from './RenderTexture';\n\nimport type { MSAA_QUALITY } from '@pixi/constants';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { IRenderableContainer, IRenderableObject, IRenderer } from '../IRenderer';\nimport type { ISystem } from '../system/ISystem';\nimport type { IBaseTextureOptions } from '../textures/BaseTexture';\n\nconst tempTransform = new Transform();\nconst tempRect = new Rectangle();\n\n// TODO could this just be part of extract?\nexport interface IGenerateTextureOptions extends IBaseTextureOptions\n{\n    /**\n     * The region of the displayObject, that shall be rendered,\n     * if no region is specified, defaults to the local bounds of the displayObject.\n     */\n    region?: Rectangle;\n    /** The resolution / device pixel ratio of the texture being generated. The default is the renderer's resolution. */\n    resolution?: number;\n    /** The number of samples of the frame buffer. The default is the renderer's multisample. */\n    multisample?: MSAA_QUALITY;\n}\n\n/**\n * System that manages the generation of textures from the renderer.\n * @memberof PIXI\n */\nexport class GenerateTextureSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: [\n            ExtensionType.RendererSystem,\n            ExtensionType.CanvasRendererSystem\n        ],\n        name: 'textureGenerator',\n    };\n\n    renderer: IRenderer;\n\n    private readonly _tempMatrix: Matrix;\n\n    constructor(renderer: IRenderer)\n    {\n        this.renderer = renderer;\n\n        this._tempMatrix = new Matrix();\n    }\n\n    /**\n     * A Useful function that returns a texture of the display object that can then be used to create sprites\n     * This can be quite useful if your displayObject is complicated and needs to be reused multiple times.\n     * @param displayObject - The displayObject the object will be generated from.\n     * @param {IGenerateTextureOptions} options - Generate texture options.\n     * @param {PIXI.Rectangle} options.region - The region of the displayObject, that shall be rendered,\n     *        if no region is specified, defaults to the local bounds of the displayObject.\n     * @param {number} [options.resolution] - If not given, the renderer's resolution is used.\n     * @param {PIXI.MSAA_QUALITY} [options.multisample] - If not given, the renderer's multisample is used.\n     * @returns a shiny new texture of the display object passed in\n     */\n    generateTexture(displayObject: IRenderableObject, options?: IGenerateTextureOptions): RenderTexture\n    {\n        const { region: manualRegion, ...textureOptions } = options || {};\n\n        const region = manualRegion?.copyTo(tempRect)\n            || (displayObject as IRenderableContainer).getLocalBounds(tempRect, true);\n        const resolution = textureOptions.resolution || this.renderer.resolution;\n\n        region.width = Math.max(region.width, 1 / resolution);\n        region.height = Math.max(region.height, 1 / resolution);\n\n        textureOptions.width = region.width;\n        textureOptions.height = region.height;\n        textureOptions.resolution = resolution;\n        textureOptions.multisample ??= this.renderer.multisample;\n\n        const renderTexture = RenderTexture.create(textureOptions);\n\n        this._tempMatrix.tx = -region.x;\n        this._tempMatrix.ty = -region.y;\n\n        const transform = displayObject.transform;\n\n        displayObject.transform = tempTransform;\n\n        this.renderer.render(displayObject, {\n            renderTexture,\n            transform: this._tempMatrix,\n            skipUpdateTransform: !!displayObject.parent,\n            blit: true,\n        });\n\n        displayObject.transform = transform;\n\n        return renderTexture;\n    }\n\n    destroy(): void\n    {\n        // ka boom!\n    }\n}\n\nextensions.add(GenerateTextureSystem);\n"],"names":[],"mappings":";;;AAUA,MAAM,gBAAgB,IAAI,UAAA,GACpB,WAAW,IAAI,UAAU;AAoBxB,MAAM,sBACb;AAAA,EAcI,YAAY,UACZ;AACI,SAAK,WAAW,UAEhB,KAAK,cAAc,IAAI;EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,gBAAgB,eAAkC,SAClD;AACU,UAAA,EAAE,QAAQ,cAAc,GAAG,eAAmB,IAAA,WAAW,CAAA,GAEzD,SAAS,cAAc,OAAO,QAAQ,KACpC,cAAuC,eAAe,UAAU,EAAI,GACtE,aAAa,eAAe,cAAc,KAAK,SAAS;AAE9D,WAAO,QAAQ,KAAK,IAAI,OAAO,OAAO,IAAI,UAAU,GACpD,OAAO,SAAS,KAAK,IAAI,OAAO,QAAQ,IAAI,UAAU,GAEtD,eAAe,QAAQ,OAAO,OAC9B,eAAe,SAAS,OAAO,QAC/B,eAAe,aAAa,YAC5B,eAAe,gBAAf,eAAe,cAAgB,KAAK,SAAS;AAEvC,UAAA,gBAAgB,cAAc,OAAO,cAAc;AAEpD,SAAA,YAAY,KAAK,CAAC,OAAO,GAC9B,KAAK,YAAY,KAAK,CAAC,OAAO;AAE9B,UAAM,YAAY,cAAc;AAEhC,WAAA,cAAc,YAAY,eAE1B,KAAK,SAAS,OAAO,eAAe;AAAA,MAChC;AAAA,MACA,WAAW,KAAK;AAAA,MAChB,qBAAqB,CAAC,CAAC,cAAc;AAAA,MACrC,MAAM;AAAA,IACT,CAAA,GAED,cAAc,YAAY,WAEnB;AAAA,EACX;AAAA,EAEA,UACA;AAAA,EAEA;AACJ;AA1Ea,sBAGF,YAA+B;AAAA,EAClC,MAAM;AAAA,IACF,cAAc;AAAA,IACd,cAAc;AAAA,EAClB;AAAA,EACA,MAAM;AACV;AAmEJ,WAAW,IAAI,qBAAqB;"}