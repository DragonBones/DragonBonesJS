{"version":3,"file":"Framebuffer.mjs","sources":["../../src/framebuffer/Framebuffer.ts"],"sourcesContent":["import { FORMATS, MIPMAP_MODES, MSAA_QUALITY, SCALE_MODES, TYPES } from '@pixi/constants';\nimport { Runner } from '@pixi/runner';\nimport { BaseTexture } from '../textures/BaseTexture';\n\nimport type { GLFramebuffer } from './GLFramebuffer';\n\n/**\n * A framebuffer can be used to render contents off of the screen. {@link PIXI.BaseRenderTexture} uses\n * one internally to render into itself. You can attach a depth or stencil buffer to a framebuffer.\n *\n * On WebGL 2 machines, shaders can output to multiple textures simultaneously with GLSL 300 ES.\n * @memberof PIXI\n */\nexport class Framebuffer\n{\n    /** Width of framebuffer in pixels. */\n    public width: number;\n\n    /** Height of framebuffer in pixels. */\n    public height: number;\n\n    /**\n     * Desired number of samples for antialiasing. 0 means AA should not be used.\n     *\n     * Experimental WebGL2 feature, allows to use antialiasing in individual renderTextures.\n     * Antialiasing is the same as for main buffer with renderer `antialias: true` options.\n     * Seriously affects GPU memory consumption and GPU performance.\n     * @example\n     * import { MSAA_QUALITY } from 'pixi.js';\n     *\n     * renderTexture.framebuffer.multisample = MSAA_QUALITY.HIGH;\n     * // ...\n     * renderer.render(myContainer, { renderTexture });\n     * renderer.framebuffer.blit(); // Copies data from MSAA framebuffer to texture\n     * @default PIXI.MSAA_QUALITY.NONE\n     */\n    public multisample: MSAA_QUALITY;\n\n    stencil: boolean;\n    depth: boolean;\n    dirtyId: number;\n    dirtyFormat: number;\n    dirtySize: number;\n    depthTexture: BaseTexture;\n    colorTextures: Array<BaseTexture>;\n    glFramebuffers: {[key: string]: GLFramebuffer};\n    disposeRunner: Runner;\n\n    /**\n     * @param width - Width of the frame buffer\n     * @param height - Height of the frame buffer\n     */\n    constructor(width: number, height: number)\n    {\n        this.width = Math.round(width);\n        this.height = Math.round(height);\n\n        if (!this.width || !this.height)\n        {\n            throw new Error('Framebuffer width or height is zero');\n        }\n\n        this.stencil = false;\n        this.depth = false;\n\n        this.dirtyId = 0;\n        this.dirtyFormat = 0;\n        this.dirtySize = 0;\n\n        this.depthTexture = null;\n        this.colorTextures = [];\n\n        this.glFramebuffers = {};\n\n        this.disposeRunner = new Runner('disposeFramebuffer');\n        this.multisample = MSAA_QUALITY.NONE;\n    }\n\n    /**\n     * Reference to the colorTexture.\n     * @readonly\n     */\n    get colorTexture(): BaseTexture\n    {\n        return this.colorTextures[0];\n    }\n\n    /**\n     * Add texture to the colorTexture array.\n     * @param index - Index of the array to add the texture to\n     * @param texture - Texture to add to the array\n     */\n    addColorTexture(index = 0, texture?: BaseTexture): this\n    {\n        // TODO add some validation to the texture - same width / height etc?\n        this.colorTextures[index] = texture || new BaseTexture(null, {\n            scaleMode: SCALE_MODES.NEAREST,\n            resolution: 1,\n            mipmap: MIPMAP_MODES.OFF,\n            width: this.width,\n            height: this.height,\n        });\n\n        this.dirtyId++;\n        this.dirtyFormat++;\n\n        return this;\n    }\n\n    /**\n     * Add a depth texture to the frame buffer.\n     * @param texture - Texture to add.\n     */\n    addDepthTexture(texture?: BaseTexture): this\n    {\n        this.depthTexture = texture || new BaseTexture(null, {\n            scaleMode: SCALE_MODES.NEAREST,\n            resolution: 1,\n            width: this.width,\n            height: this.height,\n            mipmap: MIPMAP_MODES.OFF,\n            format: FORMATS.DEPTH_COMPONENT,\n            type: TYPES.UNSIGNED_SHORT,\n        });\n\n        this.dirtyId++;\n        this.dirtyFormat++;\n\n        return this;\n    }\n\n    /** Enable depth on the frame buffer. */\n    enableDepth(): this\n    {\n        this.depth = true;\n\n        this.dirtyId++;\n        this.dirtyFormat++;\n\n        return this;\n    }\n\n    /** Enable stencil on the frame buffer. */\n    enableStencil(): this\n    {\n        this.stencil = true;\n\n        this.dirtyId++;\n        this.dirtyFormat++;\n\n        return this;\n    }\n\n    /**\n     * Resize the frame buffer\n     * @param width - Width of the frame buffer to resize to\n     * @param height - Height of the frame buffer to resize to\n     */\n    resize(width: number, height: number): void\n    {\n        width = Math.round(width);\n        height = Math.round(height);\n\n        if (!width || !height)\n        {\n            throw new Error('Framebuffer width and height must not be zero');\n        }\n\n        if (width === this.width && height === this.height) return;\n\n        this.width = width;\n        this.height = height;\n\n        this.dirtyId++;\n        this.dirtySize++;\n\n        for (let i = 0; i < this.colorTextures.length; i++)\n        {\n            const texture = this.colorTextures[i];\n            const resolution = texture.resolution;\n\n            // take into account the fact the texture may have a different resolution..\n            texture.setSize(width / resolution, height / resolution);\n        }\n\n        if (this.depthTexture)\n        {\n            const resolution = this.depthTexture.resolution;\n\n            this.depthTexture.setSize(width / resolution, height / resolution);\n        }\n    }\n\n    /** Disposes WebGL resources that are connected to this geometry. */\n    dispose(): void\n    {\n        this.disposeRunner.emit(this, false);\n    }\n\n    /** Destroys and removes the depth texture added to this framebuffer. */\n    destroyDepthTexture(): void\n    {\n        if (this.depthTexture)\n        {\n            this.depthTexture.destroy();\n            this.depthTexture = null;\n\n            ++this.dirtyId;\n            ++this.dirtyFormat;\n        }\n    }\n}\n"],"names":[],"mappings":";;;AAaO,MAAM,YACb;AAAA;AAAA;AAAA;AAAA;AAAA,EAsCI,YAAY,OAAe,QAC3B;AAII,QAHA,KAAK,QAAQ,KAAK,MAAM,KAAK,GAC7B,KAAK,SAAS,KAAK,MAAM,MAAM,GAE3B,CAAC,KAAK,SAAS,CAAC,KAAK;AAEf,YAAA,IAAI,MAAM,qCAAqC;AAGzD,SAAK,UAAU,IACf,KAAK,QAAQ,IAEb,KAAK,UAAU,GACf,KAAK,cAAc,GACnB,KAAK,YAAY,GAEjB,KAAK,eAAe,MACpB,KAAK,gBAAgB,CAErB,GAAA,KAAK,iBAAiB,IAEtB,KAAK,gBAAgB,IAAI,OAAO,oBAAoB,GACpD,KAAK,cAAc,aAAa;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,eACJ;AACW,WAAA,KAAK,cAAc,CAAC;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,QAAQ,GAAG,SAC3B;AAEI,WAAA,KAAK,cAAc,KAAK,IAAI,WAAW,IAAI,YAAY,MAAM;AAAA,MACzD,WAAW,YAAY;AAAA,MACvB,YAAY;AAAA,MACZ,QAAQ,aAAa;AAAA,MACrB,OAAO,KAAK;AAAA,MACZ,QAAQ,KAAK;AAAA,IAAA,CAChB,GAED,KAAK,WACL,KAAK,eAEE;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB,SAChB;AACI,WAAA,KAAK,eAAe,WAAW,IAAI,YAAY,MAAM;AAAA,MACjD,WAAW,YAAY;AAAA,MACvB,YAAY;AAAA,MACZ,OAAO,KAAK;AAAA,MACZ,QAAQ,KAAK;AAAA,MACb,QAAQ,aAAa;AAAA,MACrB,QAAQ,QAAQ;AAAA,MAChB,MAAM,MAAM;AAAA,IAAA,CACf,GAED,KAAK,WACL,KAAK,eAEE;AAAA,EACX;AAAA;AAAA,EAGA,cACA;AACI,WAAA,KAAK,QAAQ,IAEb,KAAK,WACL,KAAK,eAEE;AAAA,EACX;AAAA;AAAA,EAGA,gBACA;AACI,WAAA,KAAK,UAAU,IAEf,KAAK,WACL,KAAK,eAEE;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,OAAe,QACtB;AAII,QAHA,QAAQ,KAAK,MAAM,KAAK,GACxB,SAAS,KAAK,MAAM,MAAM,GAEtB,CAAC,SAAS,CAAC;AAEL,YAAA,IAAI,MAAM,+CAA+C;AAGnE,QAAI,EAAU,UAAA,KAAK,SAAS,WAAW,KAAK,SAE5C;AAAA,WAAK,QAAQ,OACb,KAAK,SAAS,QAEd,KAAK,WACL,KAAK;AAEL,eAAS,IAAI,GAAG,IAAI,KAAK,cAAc,QAAQ,KAC/C;AACI,cAAM,UAAU,KAAK,cAAc,CAAC,GAC9B,aAAa,QAAQ;AAG3B,gBAAQ,QAAQ,QAAQ,YAAY,SAAS,UAAU;AAAA,MAC3D;AAEA,UAAI,KAAK,cACT;AACU,cAAA,aAAa,KAAK,aAAa;AAErC,aAAK,aAAa,QAAQ,QAAQ,YAAY,SAAS,UAAU;AAAA,MACrE;AAAA,IAAA;AAAA,EACJ;AAAA;AAAA,EAGA,UACA;AACS,SAAA,cAAc,KAAK,MAAM,EAAK;AAAA,EACvC;AAAA;AAAA,EAGA,sBACA;AACQ,SAAK,iBAEL,KAAK,aAAa,QAAQ,GAC1B,KAAK,eAAe,MAEpB,EAAE,KAAK,SACP,EAAE,KAAK;AAAA,EAEf;AACJ;"}