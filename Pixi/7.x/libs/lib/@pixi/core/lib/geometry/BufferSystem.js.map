{"version":3,"file":"BufferSystem.js","sources":["../../src/geometry/BufferSystem.ts"],"sourcesContent":["import { extensions, ExtensionType } from '@pixi/extensions';\nimport { GLBuffer } from './GLBuffer';\n\nimport type { BUFFER_TYPE } from '@pixi/constants';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { IRenderingContext } from '../IRenderer';\nimport type { Renderer } from '../Renderer';\nimport type { ISystem } from '../system/ISystem';\nimport type { Buffer } from './Buffer';\n\n/**\n * System plugin to the renderer to manage buffers.\n *\n * WebGL uses Buffers as a way to store objects to the GPU.\n * This system makes working with them a lot easier.\n *\n * Buffers are used in three main places in WebGL\n * - geometry information\n * - Uniform information (via uniform buffer objects - a WebGL 2 only feature)\n * - Transform feedback information. (WebGL 2 only feature)\n *\n * This system will handle the binding of buffers to the GPU as well as uploading\n * them. With this system, you never need to work directly with GPU buffers, but instead work with\n * the PIXI.Buffer class.\n * @class\n * @memberof PIXI\n */\nexport class BufferSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'buffer',\n    };\n\n    CONTEXT_UID: number;\n    gl: IRenderingContext;\n\n    /** Cache for all buffers by id, used in case renderer gets destroyed or for profiling */\n    readonly managedBuffers: {[key: number]: Buffer};\n\n    /** Cache keeping track of the base bound buffer bases */\n    readonly boundBufferBases: {[key: number]: Buffer};\n\n    private renderer: Renderer;\n\n    /**\n     * @param {PIXI.Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.managedBuffers = {};\n        this.boundBufferBases = {};\n    }\n\n    /**\n     * @ignore\n     */\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this.disposeAll(true);\n\n        this.gl = this.renderer.gl;\n\n        // TODO fill out...\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    }\n\n    /**\n     * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n     * @param buffer - the buffer to bind to the renderer\n     */\n    bind(buffer: Buffer): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n        gl.bindBuffer(buffer.type, glBuffer.buffer);\n    }\n\n    unbind(type: BUFFER_TYPE): void\n    {\n        const { gl } = this;\n\n        gl.bindBuffer(type, null);\n    }\n\n    /**\n     * Binds an uniform buffer to at the given index.\n     *\n     * A cache is used so a buffer will not be bound again if already bound.\n     * @param buffer - the buffer to bind\n     * @param index - the base index to bind it to.\n     */\n    bindBufferBase(buffer: Buffer, index: number): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        if (this.boundBufferBases[index] !== buffer)\n        {\n            const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n            this.boundBufferBases[index] = buffer;\n\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n        }\n    }\n\n    /**\n     * Binds a buffer whilst also binding its range.\n     * This will make the buffer start from the offset supplied rather than 0 when it is read.\n     * @param buffer - the buffer to bind\n     * @param index - the base index to bind at, defaults to 0\n     * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n     */\n    bindBufferRange(buffer: Buffer, index?: number, offset?: number): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        offset = offset || 0;\n\n        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, 256);\n    }\n\n    /**\n     * Will ensure the data in the buffer is uploaded to the GPU.\n     * @param {PIXI.Buffer} buffer - the buffer to update\n     */\n    update(buffer: Buffer): void\n    {\n        const { gl, CONTEXT_UID } = this;\n\n        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);\n\n        if (buffer._updateID === glBuffer.updateID)\n        {\n            return;\n        }\n\n        glBuffer.updateID = buffer._updateID;\n\n        gl.bindBuffer(buffer.type, glBuffer.buffer);\n\n        if (glBuffer.byteLength >= buffer.data.byteLength)\n        {\n            // offset is always zero for now!\n            gl.bufferSubData(buffer.type, 0, buffer.data);\n        }\n        else\n        {\n            const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n\n            glBuffer.byteLength = buffer.data.byteLength;\n            gl.bufferData(buffer.type, buffer.data, drawType);\n        }\n    }\n\n    /**\n     * Disposes buffer\n     * @param {PIXI.Buffer} buffer - buffer with data\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    dispose(buffer: Buffer, contextLost?: boolean): void\n    {\n        if (!this.managedBuffers[buffer.id])\n        {\n            return;\n        }\n\n        delete this.managedBuffers[buffer.id];\n\n        const glBuffer = buffer._glBuffers[this.CONTEXT_UID];\n        const gl = this.gl;\n\n        buffer.disposeRunner.remove(this);\n\n        if (!glBuffer)\n        {\n            return;\n        }\n\n        if (!contextLost)\n        {\n            gl.deleteBuffer(glBuffer.buffer);\n        }\n\n        delete buffer._glBuffers[this.CONTEXT_UID];\n    }\n\n    /**\n     * dispose all WebGL resources of all managed buffers\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    disposeAll(contextLost?: boolean): void\n    {\n        const all: Array<any> = Object.keys(this.managedBuffers);\n\n        for (let i = 0; i < all.length; i++)\n        {\n            this.dispose(this.managedBuffers[all[i]], contextLost);\n        }\n    }\n\n    /**\n     * creates and attaches a GLBuffer object tied to the current context.\n     * @param buffer\n     * @protected\n     */\n    protected createGLBuffer(buffer: Buffer): GLBuffer\n    {\n        const { CONTEXT_UID, gl } = this;\n\n        buffer._glBuffers[CONTEXT_UID] = new GLBuffer(gl.createBuffer());\n\n        this.managedBuffers[buffer.id] = buffer;\n\n        buffer.disposeRunner.add(this);\n\n        return buffer._glBuffers[CONTEXT_UID];\n    }\n}\n\nextensions.add(BufferSystem);\n"],"names":["GLBuffer","ExtensionType","extensions"],"mappings":";;AA2BO,MAAM,aACb;AAAA;AAAA;AAAA;AAAA,EAqBI,YAAY,UACZ;AACS,SAAA,WAAW,UAChB,KAAK,iBAAiB,IACtB,KAAK,mBAAmB;EAC5B;AAAA;AAAA;AAAA;AAAA,EAKA,UACA;AACI,SAAK,WAAW;AAAA,EACpB;AAAA;AAAA,EAGU,gBACV;AACS,SAAA,WAAW,EAAI,GAEpB,KAAK,KAAK,KAAK,SAAS,IAGxB,KAAK,cAAc,KAAK,SAAS;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,KAAK,QACL;AACI,UAAM,EAAE,IAAI,gBAAgB,MAEtB,WAAW,OAAO,WAAW,WAAW,KAAK,KAAK,eAAe,MAAM;AAE7E,OAAG,WAAW,OAAO,MAAM,SAAS,MAAM;AAAA,EAC9C;AAAA,EAEA,OAAO,MACP;AACU,UAAA,EAAE,GAAO,IAAA;AAEZ,OAAA,WAAW,MAAM,IAAI;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,eAAe,QAAgB,OAC/B;AACU,UAAA,EAAE,IAAI,YAAgB,IAAA;AAE5B,QAAI,KAAK,iBAAiB,KAAK,MAAM,QACrC;AACI,YAAM,WAAW,OAAO,WAAW,WAAW,KAAK,KAAK,eAAe,MAAM;AAExE,WAAA,iBAAiB,KAAK,IAAI,QAE/B,GAAG,eAAe,GAAG,gBAAgB,OAAO,SAAS,MAAM;AAAA,IAC/D;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,gBAAgB,QAAgB,OAAgB,QAChD;AACU,UAAA,EAAE,IAAI,YAAgB,IAAA;AAE5B,aAAS,UAAU;AAEnB,UAAM,WAAW,OAAO,WAAW,WAAW,KAAK,KAAK,eAAe,MAAM;AAE1E,OAAA,gBAAgB,GAAG,gBAAgB,SAAS,GAAG,SAAS,QAAQ,SAAS,KAAK,GAAG;AAAA,EACxF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,QACP;AACI,UAAM,EAAE,IAAI,gBAAgB,MAEtB,WAAW,OAAO,WAAW,WAAW,KAAK,KAAK,eAAe,MAAM;AAEzE,QAAA,OAAO,cAAc,SAAS;AASlC,UAJA,SAAS,WAAW,OAAO,WAE3B,GAAG,WAAW,OAAO,MAAM,SAAS,MAAM,GAEtC,SAAS,cAAc,OAAO,KAAK;AAGnC,WAAG,cAAc,OAAO,MAAM,GAAG,OAAO,IAAI;AAAA,WAGhD;AACI,cAAM,WAAW,OAAO,SAAS,GAAG,cAAc,GAAG;AAE5C,iBAAA,aAAa,OAAO,KAAK,YAClC,GAAG,WAAW,OAAO,MAAM,OAAO,MAAM,QAAQ;AAAA,MACpD;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ,QAAgB,aACxB;AACI,QAAI,CAAC,KAAK,eAAe,OAAO,EAAE;AAE9B;AAGG,WAAA,KAAK,eAAe,OAAO,EAAE;AAEpC,UAAM,WAAW,OAAO,WAAW,KAAK,WAAW,GAC7C,KAAK,KAAK;AAEhB,WAAO,cAAc,OAAO,IAAI,GAE3B,aAKA,eAED,GAAG,aAAa,SAAS,MAAM,GAGnC,OAAO,OAAO,WAAW,KAAK,WAAW;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAW,aACX;AACI,UAAM,MAAkB,OAAO,KAAK,KAAK,cAAc;AAEvD,aAAS,IAAI,GAAG,IAAI,IAAI,QAAQ;AAE5B,WAAK,QAAQ,KAAK,eAAe,IAAI,CAAC,CAAC,GAAG,WAAW;AAAA,EAE7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOU,eAAe,QACzB;AACU,UAAA,EAAE,aAAa,GAAO,IAAA;AAErB,WAAA,OAAA,WAAW,WAAW,IAAI,IAAIA,kBAAS,GAAG,aAAA,CAAc,GAE/D,KAAK,eAAe,OAAO,EAAE,IAAI,QAEjC,OAAO,cAAc,IAAI,IAAI,GAEtB,OAAO,WAAW,WAAW;AAAA,EACxC;AACJ;AA3Ma,aAGF,YAA+B;AAAA,EAClC,MAAMC,WAAc,cAAA;AAAA,EACpB,MAAM;AACV;AAuMJC,WAAAA,WAAW,IAAI,YAAY;;"}