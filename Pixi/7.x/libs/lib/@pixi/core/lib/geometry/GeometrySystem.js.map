{"version":3,"file":"GeometrySystem.js","sources":["../../src/geometry/GeometrySystem.ts"],"sourcesContent":["import { BUFFER_TYPE, ENV } from '@pixi/constants';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { settings } from '@pixi/settings';\n\nimport type { DRAW_MODES } from '@pixi/constants';\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Dict } from '@pixi/utils';\nimport type { IRenderingContext } from '../IRenderer';\nimport type { Renderer } from '../Renderer';\nimport type { Program } from '../shader/Program';\nimport type { Shader } from '../shader/Shader';\nimport type { ISystem } from '../system/ISystem';\nimport type { Geometry } from './Geometry';\nimport type { GLBuffer } from './GLBuffer';\n\nconst byteSizeMap: {[key: number]: number} = { 5126: 4, 5123: 2, 5121: 1 };\n\n/**\n * System plugin to the renderer to manage geometry.\n * @memberof PIXI\n */\nexport class GeometrySystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'geometry',\n    };\n\n    /**\n     * `true` if we has `*_vertex_array_object` extension.\n     * @readonly\n     */\n    public hasVao: boolean;\n\n    /**\n     * `true` if has `ANGLE_instanced_arrays` extension.\n     * @readonly\n     */\n    public hasInstance: boolean;\n\n    /**\n     * `true` if support `gl.UNSIGNED_INT` in `gl.drawElements` or `gl.drawElementsInstanced`.\n     * @readonly\n     */\n    public canUseUInt32ElementIndex: boolean;\n\n    protected CONTEXT_UID: number;\n    protected gl: IRenderingContext;\n    protected _activeGeometry: Geometry;\n    protected _activeVao: WebGLVertexArrayObject;\n    protected _boundBuffer: GLBuffer;\n\n    /** Cache for all geometries by id, used in case renderer gets destroyed or for profiling. */\n    readonly managedGeometries: {[key: number]: Geometry};\n\n    /** Renderer that owns this {@link GeometrySystem}. */\n    private renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n        this.canUseUInt32ElementIndex = false;\n        this.managedGeometries = {};\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this.disposeAll(true);\n\n        const gl = this.gl = this.renderer.gl;\n        const context = this.renderer.context;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        // webgl2\n        if (context.webGLVersion !== 2)\n        {\n            // webgl 1!\n            let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;\n\n            if (settings.PREFER_ENV === ENV.WEBGL_LEGACY)\n            {\n                nativeVaoExtension = null;\n            }\n\n            if (nativeVaoExtension)\n            {\n                gl.createVertexArray = (): WebGLVertexArrayObject =>\n                    nativeVaoExtension.createVertexArrayOES();\n\n                gl.bindVertexArray = (vao): void =>\n                    nativeVaoExtension.bindVertexArrayOES(vao);\n\n                gl.deleteVertexArray = (vao): void =>\n                    nativeVaoExtension.deleteVertexArrayOES(vao);\n            }\n            else\n            {\n                this.hasVao = false;\n                gl.createVertexArray = (): WebGLVertexArrayObject =>\n                    null;\n\n                gl.bindVertexArray = (): void =>\n                    null;\n\n                gl.deleteVertexArray = (): void =>\n                    null;\n            }\n        }\n\n        if (context.webGLVersion !== 2)\n        {\n            const instanceExt = gl.getExtension('ANGLE_instanced_arrays');\n\n            if (instanceExt)\n            {\n                gl.vertexAttribDivisor = (a, b): void =>\n                    instanceExt.vertexAttribDivisorANGLE(a, b);\n\n                gl.drawElementsInstanced = (a, b, c, d, e): void =>\n                    instanceExt.drawElementsInstancedANGLE(a, b, c, d, e);\n\n                gl.drawArraysInstanced = (a, b, c, d): void =>\n                    instanceExt.drawArraysInstancedANGLE(a, b, c, d);\n            }\n            else\n            {\n                this.hasInstance = false;\n            }\n        }\n\n        this.canUseUInt32ElementIndex = context.webGLVersion === 2 || !!context.extensions.uint32ElementIndex;\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @param geometry - Instance of geometry to bind.\n     * @param shader - Instance of shader to use vao for.\n     */\n    bind(geometry?: Geometry, shader?: Shader): void\n    {\n        shader = shader || this.renderer.shader.shader;\n\n        const { gl } = this;\n\n        // not sure the best way to address this..\n        // currently different shaders require different VAOs for the same geometry\n        // Still mulling over the best way to solve this one..\n        // will likely need to modify the shader attribute locations at run time!\n        let vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n        let incRefCount = false;\n\n        if (!vaos)\n        {\n            this.managedGeometries[geometry.id] = geometry;\n            geometry.disposeRunner.add(this);\n            geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};\n            incRefCount = true;\n        }\n\n        const vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);\n\n        this._activeGeometry = geometry;\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            if (this.hasVao)\n            {\n                gl.bindVertexArray(vao);\n            }\n            else\n            {\n                this.activateVao(geometry, shader.program);\n            }\n        }\n\n        // TODO - optimise later!\n        // don't need to loop through if nothing changed!\n        // maybe look to add an 'autoupdate' to geometry?\n        this.updateBuffers();\n    }\n\n    /** Reset and unbind any active VAO and geometry. */\n    reset(): void\n    {\n        this.unbind();\n    }\n\n    /** Update buffers of the currently bound geometry. */\n    updateBuffers(): void\n    {\n        const geometry = this._activeGeometry;\n\n        const bufferSystem = this.renderer.buffer;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            bufferSystem.update(buffer);\n        }\n    }\n\n    /**\n     * Check compatibility between a geometry and a program\n     * @param geometry - Geometry instance.\n     * @param program - Program instance.\n     */\n    protected checkCompatibility(geometry: Geometry, program: Program): void\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program.attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Takes a geometry and program and generates a unique signature for them.\n     * @param geometry - To get signature from.\n     * @param program - To test geometry against.\n     * @returns - Unique signature of the geometry and program\n     */\n    protected getSignature(geometry: Geometry, program: Program): string\n    {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program.attributeData;\n\n        const strings = ['g', geometry.id];\n\n        for (const i in attribs)\n        {\n            if (shaderAttributes[i])\n            {\n                strings.push(i, shaderAttributes[i].location);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    /**\n     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n     * attribute locations.\n     * @param geometry - Instance of geometry to to generate Vao for.\n     * @param shader - Instance of the shader.\n     * @param incRefCount - Increment refCount of all geometry buffers.\n     */\n    protected initGeometryVao(geometry: Geometry, shader: Shader, incRefCount = true): WebGLVertexArrayObject\n    {\n        const gl = this.gl;\n        const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this.renderer.buffer;\n        const program = shader.program;\n\n        if (!program.glPrograms[CONTEXT_UID])\n        {\n            this.renderer.shader.generateProgram(shader);\n        }\n\n        this.checkCompatibility(geometry, program);\n\n        const signature = this.getSignature(geometry, program);\n\n        const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n\n        let vao = vaoObjectHash[signature];\n\n        if (vao)\n        {\n            // this will give us easy access to the vao\n            vaoObjectHash[program.id] = vao;\n\n            return vao;\n        }\n\n        const buffers = geometry.buffers;\n        const attributes = geometry.attributes;\n        const tempStride: Dict<number> = {};\n        const tempStart: Dict<number> = {};\n\n        for (const j in buffers)\n        {\n            tempStride[j] = 0;\n            tempStart[j] = 0;\n        }\n\n        for (const j in attributes)\n        {\n            if (!attributes[j].size && program.attributeData[j])\n            {\n                attributes[j].size = program.attributeData[j].size;\n            }\n            else if (!attributes[j].size)\n            {\n                console.warn(`PIXI Geometry attribute '${j}' size cannot be determined (likely the bound shader does not have the attribute)`);  // eslint-disable-line\n            }\n\n            tempStride[attributes[j].buffer] += attributes[j].size * byteSizeMap[attributes[j].type];\n        }\n\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const attribSize = attribute.size;\n\n            if (attribute.stride === undefined)\n            {\n                if (tempStride[attribute.buffer] === attribSize * byteSizeMap[attribute.type])\n                {\n                    attribute.stride = 0;\n                }\n                else\n                {\n                    attribute.stride = tempStride[attribute.buffer];\n                }\n            }\n\n            if (attribute.start === undefined)\n            {\n                attribute.start = tempStart[attribute.buffer];\n\n                tempStart[attribute.buffer] += attribSize * byteSizeMap[attribute.type];\n            }\n        }\n\n        // @TODO: We don't know if VAO is supported.\n        vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            bufferSystem.bind(buffer);\n\n            if (incRefCount)\n            {\n                buffer._glBuffers[CONTEXT_UID].refCount++;\n            }\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n\n        this.activateVao(geometry, program);\n\n        // add it to the cache!\n        vaoObjectHash[program.id] = vao;\n        vaoObjectHash[signature] = vao;\n\n        gl.bindVertexArray(null);\n        bufferSystem.unbind(BUFFER_TYPE.ARRAY_BUFFER);\n\n        return vao;\n    }\n\n    /**\n     * Disposes geometry.\n     * @param geometry - Geometry with buffers. Only VAO will be disposed\n     * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    disposeGeometry(geometry: Geometry, contextLost?: boolean): void\n    {\n        if (!this.managedGeometries[geometry.id])\n        {\n            return;\n        }\n\n        delete this.managedGeometries[geometry.id];\n\n        const vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];\n        const gl = this.gl;\n        const buffers = geometry.buffers;\n        const bufferSystem = this.renderer?.buffer;\n\n        geometry.disposeRunner.remove(this);\n\n        if (!vaos)\n        {\n            return;\n        }\n\n        // bufferSystem may have already been destroyed..\n        // if this is the case, there is no need to destroy the geometry buffers...\n        // they already have been!\n        if (bufferSystem)\n        {\n            for (let i = 0; i < buffers.length; i++)\n            {\n                const buf = buffers[i]._glBuffers[this.CONTEXT_UID];\n\n                // my be null as context may have changed right before the dispose is called\n                if (buf)\n                {\n                    buf.refCount--;\n                    if (buf.refCount === 0 && !contextLost)\n                    {\n                        bufferSystem.dispose(buffers[i], contextLost);\n                    }\n                }\n            }\n        }\n\n        if (!contextLost)\n        {\n            for (const vaoId in vaos)\n            {\n                // delete only signatures, everything else are copies\n                if (vaoId[0] === 'g')\n                {\n                    const vao = vaos[vaoId];\n\n                    if (this._activeVao === vao)\n                    {\n                        this.unbind();\n                    }\n                    gl.deleteVertexArray(vao);\n                }\n            }\n        }\n\n        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];\n    }\n\n    /**\n     * Dispose all WebGL resources of all managed geometries.\n     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    disposeAll(contextLost?: boolean): void\n    {\n        const all: Array<any> = Object.keys(this.managedGeometries);\n\n        for (let i = 0; i < all.length; i++)\n        {\n            this.disposeGeometry(this.managedGeometries[all[i]], contextLost);\n        }\n    }\n\n    /**\n     * Activate vertex array object.\n     * @param geometry - Geometry instance.\n     * @param program - Shader program instance.\n     */\n    protected activateVao(geometry: Geometry, program: Program): void\n    {\n        const gl = this.gl;\n        const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this.renderer.buffer;\n        const buffers = geometry.buffers;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            bufferSystem.bind(geometry.indexBuffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = buffers[attribute.buffer];\n            const glBuffer = buffer._glBuffers[CONTEXT_UID];\n\n            if (program.attributeData[j])\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    bufferSystem.bind(buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = program.attributeData[j].location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                gl.vertexAttribPointer(location,\n                    attribute.size,\n                    attribute.type || gl.FLOAT,\n                    attribute.normalized,\n                    attribute.stride,\n                    attribute.start);\n\n                if (attribute.instance)\n                {\n                    // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        gl.vertexAttribDivisor(location, attribute.divisor);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the currently bound geometry.\n     * @param type - The type primitive to render.\n     * @param size - The number of elements to be rendered. If not specified, all vertices after the\n     *  starting vertex will be drawn.\n     * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n     *  all instances will be drawn.\n     */\n    draw(type: DRAW_MODES, size?: number, start?: number, instanceCount?: number): this\n    {\n        const { gl } = this;\n        const geometry = this._activeGeometry;\n\n        // TODO.. this should not change so maybe cache the function?\n\n        if (geometry.indexBuffer)\n        {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n            if (byteSize === 2 || (byteSize === 4 && this.canUseUInt32ElementIndex))\n            {\n                if (geometry.instanced)\n                {\n                    /* eslint-disable max-len */\n                    gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1);\n                    /* eslint-enable max-len */\n                }\n                else\n                {\n                    /* eslint-disable max-len */\n                    gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n                    /* eslint-enable max-len */\n                }\n            }\n            else\n            {\n                console.warn('unsupported index buffer type: uint32');\n            }\n        }\n        else if (geometry.instanced)\n        {\n            // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);\n        }\n        else\n        {\n            gl.drawArrays(type, start, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    /** Unbind/reset everything. */\n    protected unbind(): void\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n\n    destroy(): void\n    {\n        this.renderer = null;\n    }\n}\n\nextensions.add(GeometrySystem);\n"],"names":["settings","ENV","BUFFER_TYPE","ExtensionType","extensions"],"mappings":"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"}