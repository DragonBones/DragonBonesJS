{"version":3,"file":"AbstractMultiResource.mjs","sources":["../../../src/textures/resources/AbstractMultiResource.ts"],"sourcesContent":["import { BaseTexture } from '../BaseTexture';\nimport { autoDetectResource } from './autoDetectResource';\nimport { Resource } from './Resource';\n\nimport type { ISize } from '@pixi/math';\nimport type { IAutoDetectOptions } from './autoDetectResource';\n\n/**\n * Resource that can manage several resource (items) inside.\n * All resources need to have the same pixel size.\n * Parent class for CubeResource and ArrayResource\n * @memberof PIXI\n */\nexport abstract class AbstractMultiResource extends Resource\n{\n    /** Number of elements in array. */\n    readonly length: number;\n\n    /**\n     * Collection of partial baseTextures that correspond to resources.\n     * @readonly\n     */\n    items: Array<BaseTexture>;\n\n    /**\n     * Dirty IDs for each part.\n     * @readonly\n     */\n    itemDirtyIds: Array<number>;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    /** Bound baseTexture, there can only be one. */\n    baseTexture: BaseTexture;\n\n    /**\n     * @param length\n     * @param options - Options to for Resource constructor\n     * @param {number} [options.width] - Width of the resource\n     * @param {number} [options.height] - Height of the resource\n     */\n    constructor(length: number, options?: ISize)\n    {\n        const { width, height } = options || {};\n\n        super(width, height);\n\n        this.items = [];\n        this.itemDirtyIds = [];\n\n        for (let i = 0; i < length; i++)\n        {\n            const partTexture = new BaseTexture();\n\n            this.items.push(partTexture);\n            // -2 - first run of texture array upload\n            // -1 - texture item was allocated\n            // >=0 - texture item uploaded , in sync with items[i].dirtyId\n            this.itemDirtyIds.push(-2);\n        }\n\n        this.length = length;\n        this._load = null;\n        this.baseTexture = null;\n    }\n\n    /**\n     * Used from ArrayResource and CubeResource constructors.\n     * @param resources - Can be resources, image elements, canvas, etc. ,\n     *  length should be same as constructor length\n     * @param options - Detect options for resources\n     */\n    protected initFromArray(resources: Array<any>, options?: IAutoDetectOptions): void\n    {\n        for (let i = 0; i < this.length; i++)\n        {\n            if (!resources[i])\n            {\n                continue;\n            }\n            if (resources[i].castToBaseTexture)\n            {\n                this.addBaseTextureAt(resources[i].castToBaseTexture(), i);\n            }\n            else if (resources[i] instanceof Resource)\n            {\n                this.addResourceAt(resources[i], i);\n            }\n            else\n            {\n                this.addResourceAt(autoDetectResource(resources[i], options), i);\n            }\n        }\n    }\n\n    /** Destroy this BaseImageResource. */\n    dispose(): void\n    {\n        for (let i = 0, len = this.length; i < len; i++)\n        {\n            this.items[i].destroy();\n        }\n        this.items = null;\n        this.itemDirtyIds = null;\n        this._load = null;\n    }\n\n    /**\n     * Set a baseTexture by ID\n     * @param baseTexture\n     * @param index - Zero-based index of resource to set\n     * @returns - Instance for chaining\n     */\n    abstract addBaseTextureAt(baseTexture: BaseTexture, index: number): this;\n\n    /**\n     * Set a resource by ID\n     * @param resource\n     * @param index - Zero-based index of resource to set\n     * @returns - Instance for chaining\n     */\n    addResourceAt(resource: Resource, index: number): this\n    {\n        if (!this.items[index])\n        {\n            throw new Error(`Index ${index} is out of bounds`);\n        }\n\n        // Inherit the first resource dimensions\n        if (resource.valid && !this.valid)\n        {\n            this.resize(resource.width, resource.height);\n        }\n\n        this.items[index].setResource(resource);\n\n        return this;\n    }\n\n    /**\n     * Set the parent base texture.\n     * @param baseTexture\n     */\n    bind(baseTexture: BaseTexture): void\n    {\n        if (this.baseTexture !== null)\n        {\n            throw new Error('Only one base texture per TextureArray is allowed');\n        }\n        super.bind(baseTexture);\n\n        for (let i = 0; i < this.length; i++)\n        {\n            this.items[i].parentTextureArray = baseTexture;\n            this.items[i].on('update', baseTexture.update, baseTexture);\n        }\n    }\n\n    /**\n     * Unset the parent base texture.\n     * @param baseTexture\n     */\n    unbind(baseTexture: BaseTexture): void\n    {\n        super.unbind(baseTexture);\n\n        for (let i = 0; i < this.length; i++)\n        {\n            this.items[i].parentTextureArray = null;\n            this.items[i].off('update', baseTexture.update, baseTexture);\n        }\n    }\n\n    /**\n     * Load all the resources simultaneously\n     * @returns - When load is resolved\n     */\n    load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const resources = this.items.map((item) => item.resource).filter((item) => item);\n\n        // TODO: also implement load part-by-part strategy\n        const promises = resources.map((item) => item.load());\n\n        this._load = Promise.all(promises)\n            .then(() =>\n            {\n                const { realWidth, realHeight } = this.items[0];\n\n                this.resize(realWidth, realHeight);\n                this.update();\n\n                return Promise.resolve(this);\n            }\n            );\n\n        return this._load;\n    }\n}\n"],"names":[],"mappings":";;;AAaO,MAAe,8BAA8B,SACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA+BI,YAAY,QAAgB,SAC5B;AACI,UAAM,EAAE,OAAO,WAAW,WAAW,CAAA;AAErC,UAAM,OAAO,MAAM,GAEnB,KAAK,QAAQ,CAAA,GACb,KAAK,eAAe,CAAA;AAEpB,aAAS,IAAI,GAAG,IAAI,QAAQ,KAC5B;AACU,YAAA,cAAc,IAAI;AAExB,WAAK,MAAM,KAAK,WAAW,GAI3B,KAAK,aAAa,KAAK,EAAE;AAAA,IAC7B;AAEA,SAAK,SAAS,QACd,KAAK,QAAQ,MACb,KAAK,cAAc;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQU,cAAc,WAAuB,SAC/C;AACI,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ;AAExB,gBAAU,CAAC,MAIZ,UAAU,CAAC,EAAE,oBAEb,KAAK,iBAAiB,UAAU,CAAC,EAAE,kBAAkB,GAAG,CAAC,IAEpD,UAAU,CAAC,aAAa,WAE7B,KAAK,cAAc,UAAU,CAAC,GAAG,CAAC,IAIlC,KAAK,cAAc,mBAAmB,UAAU,CAAC,GAAG,OAAO,GAAG,CAAC;AAAA,EAG3E;AAAA;AAAA,EAGA,UACA;AACI,aAAS,IAAI,GAAG,MAAM,KAAK,QAAQ,IAAI,KAAK;AAEnC,WAAA,MAAM,CAAC,EAAE,QAAQ;AAE1B,SAAK,QAAQ,MACb,KAAK,eAAe,MACpB,KAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,cAAc,UAAoB,OAClC;AACQ,QAAA,CAAC,KAAK,MAAM,KAAK;AAEjB,YAAM,IAAI,MAAM,SAAS,KAAK,mBAAmB;AAIrD,WAAI,SAAS,SAAS,CAAC,KAAK,SAExB,KAAK,OAAO,SAAS,OAAO,SAAS,MAAM,GAG/C,KAAK,MAAM,KAAK,EAAE,YAAY,QAAQ,GAE/B;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,KAAK,aACL;AACI,QAAI,KAAK,gBAAgB;AAEf,YAAA,IAAI,MAAM,mDAAmD;AAEvE,UAAM,KAAK,WAAW;AAEtB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ;AAE7B,WAAK,MAAM,CAAC,EAAE,qBAAqB,aACnC,KAAK,MAAM,CAAC,EAAE,GAAG,UAAU,YAAY,QAAQ,WAAW;AAAA,EAElE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,aACP;AACI,UAAM,OAAO,WAAW;AAExB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ;AAE7B,WAAK,MAAM,CAAC,EAAE,qBAAqB,MACnC,KAAK,MAAM,CAAC,EAAE,IAAI,UAAU,YAAY,QAAQ,WAAW;AAAA,EAEnE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OACA;AACI,QAAI,KAAK;AAEL,aAAO,KAAK;AAMhB,UAAM,WAHY,KAAK,MAAM,IAAI,CAAC,SAAS,KAAK,QAAQ,EAAE,OAAO,CAAC,SAAS,IAAI,EAGpD,IAAI,CAAC,SAAS,KAAK,MAAM;AAEpD,WAAA,KAAK,QAAQ,QAAQ,IAAI,QAAQ,EAC5B;AAAA,MAAK,MACN;AACI,cAAM,EAAE,WAAW,WAAA,IAAe,KAAK,MAAM,CAAC;AAEzC,eAAA,KAAA,OAAO,WAAW,UAAU,GACjC,KAAK,UAEE,QAAQ,QAAQ,IAAI;AAAA,MAC/B;AAAA,IAAA,GAGG,KAAK;AAAA,EAChB;AACJ;"}