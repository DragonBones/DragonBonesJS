{"version":3,"file":"CubeResource.mjs","sources":["../../../src/textures/resources/CubeResource.ts"],"sourcesContent":["import { TARGETS } from '@pixi/constants';\nimport { AbstractMultiResource } from './AbstractMultiResource';\n\nimport type { ISize } from '@pixi/math';\nimport type { ArrayFixed } from '@pixi/utils';\nimport type { Renderer } from '../../Renderer';\nimport type { BaseTexture } from '../BaseTexture';\nimport type { GLTexture } from '../GLTexture';\nimport type { Resource } from './Resource';\n\n/**\n * Constructor options for CubeResource.\n * @memberof PIXI\n */\nexport interface ICubeResourceOptions extends ISize\n{\n    /** Whether to auto-load resources */\n    autoLoad?: boolean;\n\n    /** In case BaseTextures are supplied, whether to copy them or use. */\n    linkBaseTexture?: boolean;\n}\n\n/**\n * Resource for a CubeTexture which contains six resources.\n * @memberof PIXI\n */\nexport class CubeResource extends AbstractMultiResource\n{\n    items: ArrayFixed<BaseTexture, 6>;\n\n    /**\n     * In case BaseTextures are supplied, whether to use same resource or bind baseTexture itself.\n     * @protected\n     */\n    linkBaseTexture: boolean;\n\n    /**\n     * @param {Array<string|PIXI.Resource>} [source] - Collection of URLs or resources\n     *        to use as the sides of the cube.\n     * @param options - ImageResource options\n     * @param {number} [options.width] - Width of resource\n     * @param {number} [options.height] - Height of resource\n     * @param {number} [options.autoLoad=true] - Whether to auto-load resources\n     * @param {number} [options.linkBaseTexture=true] - In case BaseTextures are supplied,\n     *   whether to copy them or use\n     */\n    constructor(source?: ArrayFixed<string | Resource, 6>, options?: ICubeResourceOptions)\n    {\n        const { width, height, autoLoad, linkBaseTexture } = options || {};\n\n        if (source && source.length !== CubeResource.SIDES)\n        {\n            throw new Error(`Invalid length. Got ${source.length}, expected 6`);\n        }\n\n        super(6, { width, height });\n\n        for (let i = 0; i < CubeResource.SIDES; i++)\n        {\n            this.items[i].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;\n        }\n\n        this.linkBaseTexture = linkBaseTexture !== false;\n\n        if (source)\n        {\n            this.initFromArray(source, options);\n        }\n\n        if (autoLoad !== false)\n        {\n            this.load();\n        }\n    }\n\n    /**\n     * Add binding.\n     * @param baseTexture - parent base texture\n     */\n    bind(baseTexture: BaseTexture): void\n    {\n        super.bind(baseTexture);\n\n        baseTexture.target = TARGETS.TEXTURE_CUBE_MAP;\n    }\n\n    addBaseTextureAt(baseTexture: BaseTexture, index: number, linkBaseTexture?: boolean): this\n    {\n        if (linkBaseTexture === undefined)\n        {\n            linkBaseTexture = this.linkBaseTexture;\n        }\n\n        if (!this.items[index])\n        {\n            throw new Error(`Index ${index} is out of bounds`);\n        }\n\n        if (!this.linkBaseTexture\n            || baseTexture.parentTextureArray\n            || Object.keys(baseTexture._glTextures).length > 0)\n        {\n            // copy mode\n            if (baseTexture.resource)\n            {\n                this.addResourceAt(baseTexture.resource, index);\n            }\n            else\n            {\n                throw new Error(`CubeResource does not support copying of renderTexture.`);\n            }\n        }\n        else\n        {\n            // link mode, the difficult one!\n            baseTexture.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index;\n            baseTexture.parentTextureArray = this.baseTexture;\n\n            this.items[index] = baseTexture;\n        }\n\n        if (baseTexture.valid && !this.valid)\n        {\n            this.resize(baseTexture.realWidth, baseTexture.realHeight);\n        }\n\n        this.items[index] = baseTexture;\n\n        return this;\n    }\n\n    /**\n     * Upload the resource\n     * @param renderer\n     * @param _baseTexture\n     * @param glTexture\n     * @returns {boolean} true is success\n     */\n    upload(renderer: Renderer, _baseTexture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        const dirty = this.itemDirtyIds;\n\n        for (let i = 0; i < CubeResource.SIDES; i++)\n        {\n            const side = this.items[i];\n\n            if (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId)\n            {\n                if (side.valid && side.resource)\n                {\n                    side.resource.upload(renderer, side, glTexture);\n                    dirty[i] = side.dirtyId;\n                }\n                else if (dirty[i] < -1)\n                {\n                    // either item is not valid yet, either its a renderTexture\n                    // allocate the memory\n                    renderer.gl.texImage2D(side.target, 0,\n                        glTexture.internalFormat,\n                        _baseTexture.realWidth,\n                        _baseTexture.realHeight,\n                        0,\n                        _baseTexture.format,\n                        glTexture.type,\n                        null);\n                    dirty[i] = -1;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /** Number of texture sides to store for CubeResources. */\n    static SIDES = 6;\n\n    /**\n     * Used to auto-detect the type of resource.\n     * @param {*} source - The source object\n     * @returns {boolean} `true` if source is an array of 6 elements\n     */\n    static test(source: unknown): source is ArrayFixed<string | Resource, 6>\n    {\n        return Array.isArray(source) && source.length === CubeResource.SIDES;\n    }\n}\n"],"names":["_CubeResource"],"mappings":";;AA2BO,MAAM,gBAAN,MAAMA,uBAAqB,sBAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBI,YAAY,QAA2C,SACvD;AACI,UAAM,EAAE,OAAO,QAAQ,UAAU,gBAAgB,IAAI,WAAW;AAE5D,QAAA,UAAU,OAAO,WAAWA,eAAa;AAEzC,YAAM,IAAI,MAAM,uBAAuB,OAAO,MAAM,cAAc;AAGtE,UAAM,GAAG,EAAE,OAAO,OAAQ,CAAA;AAE1B,aAAS,IAAI,GAAG,IAAIA,eAAa,OAAO;AAEpC,WAAK,MAAM,CAAC,EAAE,SAAS,QAAQ,8BAA8B;AAGjE,SAAK,kBAAkB,oBAAoB,IAEvC,UAEA,KAAK,cAAc,QAAQ,OAAO,GAGlC,aAAa,MAEb,KAAK;EAEb;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,KAAK,aACL;AACI,UAAM,KAAK,WAAW,GAEtB,YAAY,SAAS,QAAQ;AAAA,EACjC;AAAA,EAEA,iBAAiB,aAA0B,OAAe,iBAC1D;AACQ,QAAA,oBAAoB,WAEpB,kBAAkB,KAAK,kBAGvB,CAAC,KAAK,MAAM,KAAK;AAEjB,YAAM,IAAI,MAAM,SAAS,KAAK,mBAAmB;AAGjD,QAAA,CAAC,KAAK,mBACH,YAAY,sBACZ,OAAO,KAAK,YAAY,WAAW,EAAE,SAAS;AAGjD,UAAI,YAAY;AAEP,aAAA,cAAc,YAAY,UAAU,KAAK;AAAA;AAIxC,cAAA,IAAI,MAAM,yDAAyD;AAAA;AAMjE,kBAAA,SAAS,QAAQ,8BAA8B,OAC3D,YAAY,qBAAqB,KAAK,aAEtC,KAAK,MAAM,KAAK,IAAI;AAGxB,WAAI,YAAY,SAAS,CAAC,KAAK,SAE3B,KAAK,OAAO,YAAY,WAAW,YAAY,UAAU,GAG7D,KAAK,MAAM,KAAK,IAAI,aAEb;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,UAAoB,cAA2B,WACtD;AACI,UAAM,QAAQ,KAAK;AAEnB,aAAS,IAAI,GAAG,IAAIA,eAAa,OAAO,KACxC;AACU,YAAA,OAAO,KAAK,MAAM,CAAC;AAEzB,OAAI,MAAM,CAAC,IAAI,KAAK,WAAW,UAAU,UAAU,aAAa,aAExD,KAAK,SAAS,KAAK,YAEnB,KAAK,SAAS,OAAO,UAAU,MAAM,SAAS,GAC9C,MAAM,CAAC,IAAI,KAAK,WAEX,MAAM,CAAC,IAAI,OAIhB,SAAS,GAAG;AAAA,QAAW,KAAK;AAAA,QAAQ;AAAA,QAChC,UAAU;AAAA,QACV,aAAa;AAAA,QACb,aAAa;AAAA,QACb;AAAA,QACA,aAAa;AAAA,QACb,UAAU;AAAA,QACV;AAAA,MAAI,GACR,MAAM,CAAC,IAAI;AAAA,IAGvB;AAEO,WAAA;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,OAAO,KAAK,QACZ;AACI,WAAO,MAAM,QAAQ,MAAM,KAAK,OAAO,WAAWA,eAAa;AAAA,EACnE;AACJ;AA/Ja,cAoJF,QAAQ;AApJZ,IAAM,eAAN;"}