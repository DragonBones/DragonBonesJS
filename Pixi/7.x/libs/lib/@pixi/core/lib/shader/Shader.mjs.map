{"version":3,"file":"Shader.mjs","sources":["../../src/shader/Shader.ts"],"sourcesContent":["import { Runner } from '@pixi/runner';\nimport { Program } from './Program';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { Dict } from '@pixi/utils';\n\n/**\n * A helper class for shaders.\n * @memberof PIXI\n */\nexport class Shader\n{\n    /** Program that the shader uses. */\n    public program: Program;\n    public uniformGroup: UniformGroup;\n\n    /**\n     * Used internally to bind uniform buffer objects.\n     * @ignore\n     */\n    uniformBindCount = 0;\n\n    disposeRunner: Runner;\n\n    /**\n     * @param program - The program the shader will use.\n     * @param uniforms - Custom uniforms to use to augment the built-in ones.\n     */\n    constructor(program: Program, uniforms?: Dict<any>)\n    {\n        this.program = program;\n\n        // lets see whats been passed in\n        // uniforms should be converted to a uniform group\n        if (uniforms)\n        {\n            if (uniforms instanceof UniformGroup)\n            {\n                this.uniformGroup = uniforms;\n            }\n            else\n            {\n                this.uniformGroup = new UniformGroup(uniforms);\n            }\n        }\n        else\n        {\n            this.uniformGroup = new UniformGroup({});\n        }\n\n        this.disposeRunner = new Runner('disposeShader');\n    }\n\n    // TODO move to shader system..\n    checkUniformExists(name: string, group: UniformGroup): boolean\n    {\n        if (group.uniforms[name])\n        {\n            return true;\n        }\n\n        for (const i in group.uniforms)\n        {\n            const uniform = group.uniforms[i];\n\n            if (uniform.group === true) // strict check to desambiguate from Array.group\n            {\n                if (this.checkUniformExists(name, uniform))\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    destroy(): void\n    {\n        // usage count on programs?\n        // remove if not used!\n        this.uniformGroup = null;\n\n        this.disposeRunner.emit(this);\n        this.disposeRunner.destroy();\n    }\n\n    /**\n     * Shader uniform values, shortcut for `uniformGroup.uniforms`.\n     * @readonly\n     */\n    get uniforms(): Dict<any>\n    {\n        return this.uniformGroup.uniforms;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param vertexSrc - The source of the vertex shader.\n     * @param fragmentSrc - The source of the fragment shader.\n     * @param uniforms - Custom uniforms to use to augment the built-in ones.\n     * @returns A shiny new PixiJS shader!\n     */\n    static from(vertexSrc?: string, fragmentSrc?: string, uniforms?: Dict<any>): Shader\n    {\n        const program = Program.from(vertexSrc, fragmentSrc);\n\n        return new Shader(program, uniforms);\n    }\n}\n"],"names":[],"mappings":";;;AAUO,MAAM,OACb;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBI,YAAY,SAAkB,UAC9B;AATmB,SAAA,mBAAA,GAUV,KAAA,UAAU,SAIX,WAEI,oBAAoB,eAEpB,KAAK,eAAe,WAIpB,KAAK,eAAe,IAAI,aAAa,QAAQ,IAKjD,KAAK,eAAe,IAAI,aAAa,CAAA,CAAE,GAG3C,KAAK,gBAAgB,IAAI,OAAO,eAAe;AAAA,EACnD;AAAA;AAAA,EAGA,mBAAmB,MAAc,OACjC;AACQ,QAAA,MAAM,SAAS,IAAI;AAEZ,aAAA;AAGA,eAAA,KAAK,MAAM,UACtB;AACU,YAAA,UAAU,MAAM,SAAS,CAAC;AAEhC,UAAI,QAAQ,UAAU,MAEd,KAAK,mBAAmB,MAAM,OAAO;AAE9B,eAAA;AAAA,IAGnB;AAEO,WAAA;AAAA,EACX;AAAA,EAEA,UACA;AAGS,SAAA,eAAe,MAEpB,KAAK,cAAc,KAAK,IAAI,GAC5B,KAAK,cAAc,QAAQ;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,WACJ;AACI,WAAO,KAAK,aAAa;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,KAAK,WAAoB,aAAsB,UACtD;AACI,UAAM,UAAU,QAAQ,KAAK,WAAW,WAAW;AAE5C,WAAA,IAAI,OAAO,SAAS,QAAQ;AAAA,EACvC;AACJ;"}