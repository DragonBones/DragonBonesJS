{"version":3,"file":"FilterSystem.js","sources":["../../src/filters/FilterSystem.ts"],"sourcesContent":["import { CLEAR_MODES, DRAW_MODES, MSAA_QUALITY } from '@pixi/constants';\nimport { extensions, ExtensionType } from '@pixi/extensions';\nimport { Matrix, Point, Rectangle } from '@pixi/math';\nimport { RenderTexturePool } from '../renderTexture/RenderTexturePool';\nimport { UniformGroup } from '../shader/UniformGroup';\nimport { Quad } from '../utils/Quad';\nimport { QuadUv } from '../utils/QuadUv';\nimport { FilterState } from './FilterState';\n\nimport type { ExtensionMetadata } from '@pixi/extensions';\nimport type { Renderer } from '../Renderer';\nimport type { RenderTexture } from '../renderTexture/RenderTexture';\nimport type { ISystem } from '../system/ISystem';\nimport type { Filter } from './Filter';\nimport type { IFilterTarget } from './IFilterTarget';\nimport type { ISpriteMaskTarget } from './spriteMask/SpriteMaskFilter';\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nconst tempMatrix = new Matrix();\n\n/**\n * System plugin to the renderer to manage filters.\n *\n * ## Pipeline\n *\n * The FilterSystem executes the filtering pipeline by rendering the display-object into a texture, applying its\n * [filters]{@link PIXI.Filter} in series, and the last filter outputs into the final render-target.\n *\n * The filter-frame is the rectangle in world space being filtered, and those contents are mapped into\n * `(0, 0, filterFrame.width, filterFrame.height)` into the filter render-texture. The filter-frame is also called\n * the source-frame, as it is used to bind the filter render-textures. The last filter outputs to the `filterFrame`\n * in the final render-target.\n *\n * ## Usage\n *\n * {@link PIXI.Container#renderAdvanced} is an example of how to use the filter system. It is a 3 step process:\n *\n * **push**: Use {@link PIXI.FilterSystem#push} to push the set of filters to be applied on a filter-target.\n * **render**: Render the contents to be filtered using the renderer. The filter-system will only capture the contents\n *      inside the bounds of the filter-target. NOTE: Using {@link PIXI.Renderer#render} is\n *      illegal during an existing render cycle, and it may reset the filter system.\n * **pop**: Use {@link PIXI.FilterSystem#pop} to pop & execute the filters you initially pushed. It will apply them\n *      serially and output to the bounds of the filter-target.\n * @memberof PIXI\n */\nexport class FilterSystem implements ISystem\n{\n    /** @ignore */\n    static extension: ExtensionMetadata = {\n        type: ExtensionType.RendererSystem,\n        name: 'filter',\n    };\n\n    /**\n     * List of filters for the FilterSystem\n     * @member {object[]}\n     */\n    public readonly defaultFilterStack: Array<FilterState>;\n\n    /** A pool for storing filter states, save us creating new ones each tick. */\n    public statePool: Array<FilterState>;\n\n    /** Stores a bunch of POT textures used for filtering. */\n    public texturePool: RenderTexturePool;\n\n    /** Whether to clear output renderTexture in AUTO/BLIT mode. See {@link PIXI.CLEAR_MODES}. */\n    public forceClear: boolean;\n\n    /**\n     * Old padding behavior is to use the max amount instead of sum padding.\n     * Use this flag if you need the old behavior.\n     * @default false\n     */\n    public useMaxPadding: boolean;\n\n    /** A very simple geometry used when drawing a filter effect to the screen. */\n    protected quad: Quad;\n\n    /** Quad UVs */\n    protected quadUv: QuadUv;\n\n    /**\n     * Active state\n     * @member {object}\n     */\n    protected activeState: FilterState;\n\n    /**\n     * This uniform group is attached to filter uniforms when used.\n     * @property {PIXI.Rectangle} outputFrame -\n     * @property {Float32Array} inputSize -\n     * @property {Float32Array} inputPixel -\n     * @property {Float32Array} inputClamp -\n     * @property {number} resolution -\n     * @property {Float32Array} filterArea -\n     * @property {Float32Array} filterClamp -\n     */\n    protected globalUniforms: UniformGroup;\n\n    /** Temporary rect for math. */\n    private tempRect: Rectangle;\n    public renderer: Renderer;\n\n    /**\n     * @param renderer - The renderer this System works for.\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n\n        this.defaultFilterStack = [{}] as any;\n\n        this.texturePool = new RenderTexturePool();\n\n        this.statePool = [];\n\n        this.quad = new Quad();\n        this.quadUv = new QuadUv();\n        this.tempRect = new Rectangle();\n        this.activeState = {} as any;\n\n        this.globalUniforms = new UniformGroup({\n            outputFrame: new Rectangle(),\n            inputSize: new Float32Array(4),\n            inputPixel: new Float32Array(4),\n            inputClamp: new Float32Array(4),\n            resolution: 1,\n\n            // legacy variables\n            filterArea: new Float32Array(4),\n            filterClamp: new Float32Array(4),\n        }, true);\n\n        this.forceClear = false;\n        this.useMaxPadding = false;\n    }\n\n    init(): void\n    {\n        this.texturePool.setScreenSize(this.renderer.view);\n    }\n\n    /**\n     * Pushes a set of filters to be applied later to the system. This will redirect further rendering into an\n     * input render-texture for the rest of the filtering pipeline.\n     * @param {PIXI.DisplayObject} target - The target of the filter to render.\n     * @param filters - The filters to apply.\n     */\n    push(target: IFilterTarget, filters: Array<Filter>): void\n    {\n        const renderer = this.renderer;\n        const filterStack = this.defaultFilterStack;\n        const state = this.statePool.pop() || new FilterState();\n        const renderTextureSystem = renderer.renderTexture;\n        let currentResolution: number;\n        let currentMultisample: MSAA_QUALITY;\n\n        if (renderTextureSystem.current)\n        {\n            const renderTexture = renderTextureSystem.current;\n\n            currentResolution = renderTexture.resolution;\n            currentMultisample = renderTexture.multisample;\n        }\n        else\n        {\n            currentResolution = renderer.resolution;\n            currentMultisample = renderer.multisample;\n        }\n\n        let resolution = filters[0].resolution || currentResolution;\n        let multisample = filters[0].multisample ?? currentMultisample;\n        let padding = filters[0].padding;\n        let autoFit = filters[0].autoFit;\n        // We don't know whether it's a legacy filter until it was bound for the first time,\n        // therefore we have to assume that it is if legacy is undefined.\n        let legacy = filters[0].legacy ?? true;\n\n        for (let i = 1; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            // let's use the lowest resolution\n            resolution = Math.min(resolution, filter.resolution || currentResolution);\n            // let's use the lowest number of samples\n            multisample = Math.min(multisample, filter.multisample ?? currentMultisample);\n            // figure out the padding required for filters\n            padding = this.useMaxPadding\n                // old behavior: use largest amount of padding!\n                ? Math.max(padding, filter.padding)\n                // new behavior: sum the padding\n                : padding + filter.padding;\n            // only auto fit if all filters are autofit\n            autoFit = autoFit && filter.autoFit;\n\n            legacy = legacy || (filter.legacy ?? true);\n        }\n\n        if (filterStack.length === 1)\n        {\n            this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;\n        }\n\n        filterStack.push(state);\n\n        state.resolution = resolution;\n        state.multisample = multisample;\n\n        state.legacy = legacy;\n\n        state.target = target;\n        state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));\n\n        state.sourceFrame.pad(padding);\n\n        const sourceFrameProjected = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);\n\n        // Project source frame into world space (if projection is applied)\n        if (renderer.projection.transform)\n        {\n            this.transformAABB(\n                tempMatrix.copyFrom(renderer.projection.transform).invert(),\n                sourceFrameProjected\n            );\n        }\n\n        if (autoFit)\n        {\n            state.sourceFrame.fit(sourceFrameProjected);\n\n            if (state.sourceFrame.width <= 0 || state.sourceFrame.height <= 0)\n            {\n                state.sourceFrame.width = 0;\n                state.sourceFrame.height = 0;\n            }\n        }\n        else if (!state.sourceFrame.intersects(sourceFrameProjected))\n        {\n            state.sourceFrame.width = 0;\n            state.sourceFrame.height = 0;\n        }\n\n        // Round sourceFrame in screen space based on render-texture.\n        this.roundFrame(\n            state.sourceFrame,\n            renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\n            renderTextureSystem.sourceFrame,\n            renderTextureSystem.destinationFrame,\n            renderer.projection.transform,\n        );\n\n        state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height,\n            resolution, multisample);\n        state.filters = filters;\n\n        state.destinationFrame.width = state.renderTexture.width;\n        state.destinationFrame.height = state.renderTexture.height;\n\n        const destinationFrame = this.tempRect;\n\n        destinationFrame.x = 0;\n        destinationFrame.y = 0;\n        destinationFrame.width = state.sourceFrame.width;\n        destinationFrame.height = state.sourceFrame.height;\n\n        state.renderTexture.filterFrame = state.sourceFrame;\n        state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);\n        state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);\n\n        state.transform = renderer.projection.transform;\n        renderer.projection.transform = null;\n        renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);\n        renderer.framebuffer.clear(0, 0, 0, 0);\n    }\n\n    /** Pops off the filter and applies it. */\n    pop(): void\n    {\n        const filterStack = this.defaultFilterStack;\n        const state = filterStack.pop();\n        const filters = state.filters;\n\n        this.activeState = state;\n\n        const globalUniforms = this.globalUniforms.uniforms;\n\n        globalUniforms.outputFrame = state.sourceFrame;\n        globalUniforms.resolution = state.resolution;\n\n        const inputSize = globalUniforms.inputSize;\n        const inputPixel = globalUniforms.inputPixel;\n        const inputClamp = globalUniforms.inputClamp;\n\n        inputSize[0] = state.destinationFrame.width;\n        inputSize[1] = state.destinationFrame.height;\n        inputSize[2] = 1.0 / inputSize[0];\n        inputSize[3] = 1.0 / inputSize[1];\n\n        inputPixel[0] = Math.round(inputSize[0] * state.resolution);\n        inputPixel[1] = Math.round(inputSize[1] * state.resolution);\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (state.sourceFrame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (state.sourceFrame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        // only update the rect if its legacy..\n        if (state.legacy)\n        {\n            const filterArea = globalUniforms.filterArea;\n\n            filterArea[0] = state.destinationFrame.width;\n            filterArea[1] = state.destinationFrame.height;\n            filterArea[2] = state.sourceFrame.x;\n            filterArea[3] = state.sourceFrame.y;\n\n            globalUniforms.filterClamp = globalUniforms.inputClamp;\n        }\n\n        this.globalUniforms.update();\n\n        const lastState = filterStack[filterStack.length - 1];\n\n        this.renderer.framebuffer.blit();\n\n        if (filters.length === 1)\n        {\n            filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);\n\n            this.returnFilterTexture(state.renderTexture);\n        }\n        else\n        {\n            let flip = state.renderTexture;\n            let flop = this.getOptimalFilterTexture(\n                flip.width,\n                flip.height,\n                state.resolution\n            );\n\n            flop.filterFrame = flip.filterFrame;\n\n            let i = 0;\n\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                if (i === 1 && state.multisample > 1)\n                {\n                    flop = this.getOptimalFilterTexture(\n                        flip.width,\n                        flip.height,\n                        state.resolution\n                    );\n\n                    flop.filterFrame = flip.filterFrame;\n                }\n\n                filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);\n\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);\n\n            if (i > 1 && state.multisample > 1)\n            {\n                this.returnFilterTexture(state.renderTexture);\n            }\n\n            this.returnFilterTexture(flip);\n            this.returnFilterTexture(flop);\n        }\n\n        // lastState.renderTexture is blitted when lastState is popped\n\n        state.clear();\n        this.statePool.push(state);\n    }\n\n    /**\n     * Binds a renderTexture with corresponding `filterFrame`, clears it if mode corresponds.\n     * @param filterTexture - renderTexture to bind, should belong to filter pool or filter stack\n     * @param clearMode - clearMode, by default its CLEAR/YES. See {@link PIXI.CLEAR_MODES}\n     */\n    bindAndClear(filterTexture: RenderTexture, clearMode: CLEAR_MODES = CLEAR_MODES.CLEAR): void\n    {\n        const {\n            renderTexture: renderTextureSystem,\n            state: stateSystem,\n        } = this.renderer;\n\n        if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture)\n        {\n            // Restore projection transform if rendering into the output render-target.\n            this.renderer.projection.transform = this.activeState.transform;\n        }\n        else\n        {\n            // Prevent projection within filtering pipeline.\n            this.renderer.projection.transform = null;\n        }\n\n        if (filterTexture?.filterFrame)\n        {\n            const destinationFrame = this.tempRect;\n\n            destinationFrame.x = 0;\n            destinationFrame.y = 0;\n            destinationFrame.width = filterTexture.filterFrame.width;\n            destinationFrame.height = filterTexture.filterFrame.height;\n\n            renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);\n        }\n        else if (filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture)\n        {\n            renderTextureSystem.bind(filterTexture);\n        }\n        else\n        {\n            // Restore binding for output render-target.\n            this.renderer.renderTexture.bind(\n                filterTexture,\n                this.activeState.bindingSourceFrame,\n                this.activeState.bindingDestinationFrame\n            );\n        }\n\n        // Clear the texture in BLIT mode if blending is disabled or the forceClear flag is set. The blending\n        // is stored in the 0th bit of the state.\n        const autoClear = (stateSystem.stateId & 1) || this.forceClear;\n\n        if (clearMode === CLEAR_MODES.CLEAR\n            || (clearMode === CLEAR_MODES.BLIT && autoClear))\n        {\n            // Use framebuffer.clear because we want to clear the whole filter texture, not just the filtering\n            // area over which the shaders are run. This is because filters may sampling outside of it (e.g. blur)\n            // instead of clamping their arithmetic.\n            this.renderer.framebuffer.clear(0, 0, 0, 0);\n        }\n    }\n\n    /**\n     * Draws a filter using the default rendering process.\n     *\n     * This should be called only by {@link PIXI.Filter#apply}.\n     * @param filter - The filter to draw.\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    applyFilter(filter: Filter, input: RenderTexture, output: RenderTexture, clearMode?: CLEAR_MODES): void\n    {\n        const renderer = this.renderer;\n\n        // Set state before binding, so bindAndClear gets the blend mode.\n        renderer.state.set(filter.state);\n        this.bindAndClear(output, clearMode);\n\n        // set the uniforms..\n        filter.uniforms.uSampler = input;\n        filter.uniforms.filterGlobals = this.globalUniforms;\n\n        // TODO make it so that the order of this does not matter..\n        // because it does at the moment cos of global uniforms.\n        // they need to get resynced\n        renderer.shader.bind(filter);\n\n        // check to see if the filter is a legacy one..\n        filter.legacy = !!filter.program.attributeData.aTextureCoord;\n\n        if (filter.legacy)\n        {\n            this.quadUv.map(input._frame, input.filterFrame);\n\n            renderer.geometry.bind(this.quadUv);\n            renderer.geometry.draw(DRAW_MODES.TRIANGLES);\n        }\n        else\n        {\n            renderer.geometry.bind(this.quad);\n            renderer.geometry.draw(DRAW_MODES.TRIANGLE_STRIP);\n        }\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {PIXI.Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    calculateSpriteMatrix(outputMatrix: Matrix, sprite: ISpriteMaskTarget): Matrix\n    {\n        const { sourceFrame, destinationFrame } = this.activeState;\n        const { orig } = sprite._texture;\n        const mappedMatrix = outputMatrix.set(destinationFrame.width, 0, 0,\n            destinationFrame.height, sourceFrame.x, sourceFrame.y);\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.TEMP_MATRIX);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    /** Destroys this Filter System. */\n    destroy(): void\n    {\n        this.renderer = null;\n\n        // Those textures has to be destroyed by RenderTextureSystem or FramebufferSystem\n        this.texturePool.clear(false);\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture in real pixels.\n     * @param minHeight - The minimum height of the render texture in real pixels.\n     * @param resolution - The resolution of the render texture.\n     * @param multisample - Number of samples of the render texture.\n     * @returns - The new render texture.\n     */\n    protected getOptimalFilterTexture(minWidth: number, minHeight: number, resolution = 1,\n        multisample: MSAA_QUALITY = MSAA_QUALITY.NONE): RenderTexture\n    {\n        return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);\n    }\n\n    /**\n     * Gets extra render texture to use inside current filter\n     * To be compliant with older filters, you can use params in any order\n     * @param input - renderTexture from which size and resolution will be copied\n     * @param resolution - override resolution of the renderTexture\n     * @param multisample - number of samples of the renderTexture\n     */\n    getFilterTexture(input?: RenderTexture, resolution?: number, multisample?: MSAA_QUALITY): RenderTexture\n    {\n        if (typeof input === 'number')\n        {\n            const swap = input;\n\n            input = resolution as any;\n            resolution = swap;\n        }\n\n        input = input || this.activeState.renderTexture;\n\n        const filterTexture = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution,\n            multisample || MSAA_QUALITY.NONE);\n\n        filterTexture.filterFrame = input.filterFrame;\n\n        return filterTexture;\n    }\n\n    /**\n     * Frees a render texture back into the pool.\n     * @param renderTexture - The renderTarget to free\n     */\n    returnFilterTexture(renderTexture: RenderTexture): void\n    {\n        this.texturePool.returnTexture(renderTexture);\n    }\n\n    /** Empties the texture pool. */\n    emptyPool(): void\n    {\n        this.texturePool.clear(true);\n    }\n\n    /** Calls `texturePool.resize()`, affects fullScreen renderTextures. */\n    resize(): void\n    {\n        this.texturePool.setScreenSize(this.renderer.view);\n    }\n\n    /**\n     * @param matrix - first param\n     * @param rect - second param\n     */\n    private transformAABB(matrix: Matrix, rect: Rectangle): void\n    {\n        const lt = tempPoints[0];\n        const lb = tempPoints[1];\n        const rt = tempPoints[2];\n        const rb = tempPoints[3];\n\n        lt.set(rect.left, rect.top);\n        lb.set(rect.left, rect.bottom);\n        rt.set(rect.right, rect.top);\n        rb.set(rect.right, rect.bottom);\n\n        matrix.apply(lt, lt);\n        matrix.apply(lb, lb);\n        matrix.apply(rt, rt);\n        matrix.apply(rb, rb);\n\n        const x0 = Math.min(lt.x, lb.x, rt.x, rb.x);\n        const y0 = Math.min(lt.y, lb.y, rt.y, rb.y);\n        const x1 = Math.max(lt.x, lb.x, rt.x, rb.x);\n        const y1 = Math.max(lt.y, lb.y, rt.y, rb.y);\n\n        rect.x = x0;\n        rect.y = y0;\n        rect.width = x1 - x0;\n        rect.height = y1 - y0;\n    }\n\n    private roundFrame(\n        frame: Rectangle,\n        resolution: number,\n        bindingSourceFrame: Rectangle,\n        bindingDestinationFrame: Rectangle,\n        transform?: Matrix\n    )\n    {\n        if (frame.width <= 0 || frame.height <= 0 || bindingSourceFrame.width <= 0 || bindingSourceFrame.height <= 0)\n        {\n            return;\n        }\n\n        if (transform)\n        {\n            const { a, b, c, d } = transform;\n\n            // Skip if skew/rotation present in matrix, except for multiple of 90° rotation. If rotation\n            // is a multiple of 90°, then either pair of (b,c) or (a,d) will be (0,0).\n            if ((Math.abs(b) > 1e-4 || Math.abs(c) > 1e-4)\n                && (Math.abs(a) > 1e-4 || Math.abs(d) > 1e-4))\n            {\n                return;\n            }\n        }\n\n        transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();\n\n        // Get forward transform from world space to screen space\n        transform\n            .translate(-bindingSourceFrame.x, -bindingSourceFrame.y)\n            .scale(\n                bindingDestinationFrame.width / bindingSourceFrame.width,\n                bindingDestinationFrame.height / bindingSourceFrame.height)\n            .translate(bindingDestinationFrame.x, bindingDestinationFrame.y);\n\n        // Convert frame to screen space\n        this.transformAABB(transform, frame);\n\n        // Round frame in screen space\n        frame.ceil(resolution);\n\n        // Project back into world space.\n        this.transformAABB(transform.invert(), frame);\n    }\n}\n\nextensions.add(FilterSystem);\n"],"names":["Point","Matrix","RenderTexturePool","Quad","QuadUv","Rectangle","UniformGroup","FilterState","CLEAR_MODES","DRAW_MODES","MSAA_QUALITY","ExtensionType","extensions"],"mappings":"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"}