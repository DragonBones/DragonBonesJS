{"version":3,"file":"MaskData.js","sources":["../../src/mask/MaskData.ts"],"sourcesContent":["import { MASK_TYPES } from '@pixi/constants';\nimport { Filter } from '../filters/Filter';\n\nimport type { MSAA_QUALITY } from '@pixi/constants';\nimport type { Matrix, Rectangle } from '@pixi/math';\nimport type { IFilterTarget } from '../filters/IFilterTarget';\nimport type { ISpriteMaskFilter } from '../filters/spriteMask/SpriteMaskFilter';\nimport type { Renderer } from '../Renderer';\n\nexport interface IMaskTarget extends IFilterTarget\n{\n    renderable: boolean;\n    isSprite?: boolean;\n    worldTransform: Matrix;\n    isFastRect?(): boolean;\n    getBounds(skipUpdate?: boolean, rect?: Rectangle): Rectangle;\n    render(renderer: Renderer): void;\n}\n/**\n * Component for masked elements.\n *\n * Holds mask mode and temporary data about current mask.\n * @memberof PIXI\n */\nexport class MaskData\n{\n    /** Mask type */\n    public type: MASK_TYPES;\n\n    /**\n     * Whether we know the mask type beforehand\n     * @default true\n     */\n    public autoDetect: boolean;\n\n    /**\n     * Which element we use to mask\n     * @member {PIXI.DisplayObject}\n     */\n    public maskObject: IMaskTarget;\n\n    /** Whether it belongs to MaskSystem pool */\n    public pooled: boolean;\n\n    /** Indicator of the type (always true for {@link PIXI.MaskData} objects) */\n    public isMaskData: boolean;// webdoc crashes if the type is true because reasons... (will fix)\n\n    /**\n     * Resolution of the sprite mask filter.\n     * If set to `null` or `0`, the resolution of the current render target is used.\n     * @default null\n     */\n    public resolution: number | null;\n\n    /**\n     * Number of samples of the sprite mask filter.\n     * If set to `null`, the sample count of the current render target is used.\n     * @default PIXI.Filter.defaultMultisample\n     */\n    public multisample: MSAA_QUALITY | null;\n\n    /** If enabled is true the mask is applied, if false it will not. */\n    public enabled: boolean;\n\n    /**\n     * Color mask.\n     * @see PIXI.COLOR_MASK_BITS\n     */\n    public colorMask: number;\n\n    /**\n     * The sprite mask filter wrapped in an array.\n     * @private\n     */\n    _filters: ISpriteMaskFilter[];\n\n    /**\n     * Stencil counter above the mask in stack\n     * @private\n     */\n    _stencilCounter: number;\n\n    /**\n     * Scissor counter above the mask in stack\n     * @private\n     */\n    _scissorCounter: number;\n\n    /**\n     * Scissor operation above the mask in stack.\n     * Null if _scissorCounter is zero, rectangle instance if positive.\n     * @private\n     */\n    _scissorRect: Rectangle;\n\n    /**\n     * pre-computed scissor rect\n     * does become _scissorRect when mask is actually pushed\n     * @private\n     */\n    _scissorRectLocal: Rectangle;\n\n    /**\n     * pre-computed color mask\n     * @private\n     */\n    _colorMask: number;\n\n    /**\n     * Targeted element. Temporary variable set by MaskSystem\n     * @member {PIXI.DisplayObject}\n     * @private\n     */\n    _target: IMaskTarget;\n\n    /**\n     * Create MaskData\n     * @param {PIXI.DisplayObject} [maskObject=null] - object that describes the mask\n     */\n    constructor(maskObject: IMaskTarget = null)\n    {\n        this.type = MASK_TYPES.NONE;\n        this.autoDetect = true;\n        this.maskObject = maskObject || null;\n        this.pooled = false;\n        this.isMaskData = true;\n        this.resolution = null;\n        this.multisample = Filter.defaultMultisample;\n        this.enabled = true;\n        this.colorMask = 0xf;\n        this._filters = null;\n        this._stencilCounter = 0;\n        this._scissorCounter = 0;\n        this._scissorRect = null;\n        this._scissorRectLocal = null;\n        this._colorMask = 0xf;\n        this._target = null;\n    }\n\n    /**\n     * The sprite mask filter.\n     * If set to `null`, the default sprite mask filter is used.\n     * @default null\n     */\n    get filter(): ISpriteMaskFilter\n    {\n        return this._filters ? this._filters[0] : null;\n    }\n\n    set filter(value: ISpriteMaskFilter)\n    {\n        if (value)\n        {\n            if (this._filters)\n            {\n                this._filters[0] = value;\n            }\n            else\n            {\n                this._filters = [value];\n            }\n        }\n        else\n        {\n            this._filters = null;\n        }\n    }\n\n    /** Resets the mask data after popMask(). */\n    reset(): void\n    {\n        if (this.pooled)\n        {\n            this.maskObject = null;\n\n            this.type = MASK_TYPES.NONE;\n\n            this.autoDetect = true;\n        }\n\n        this._target = null;\n        this._scissorRectLocal = null;\n    }\n\n    /**\n     * Copies counters from maskData above, called from pushMask().\n     * @param maskAbove\n     */\n    copyCountersOrReset(maskAbove?: MaskData): void\n    {\n        if (maskAbove)\n        {\n            this._stencilCounter = maskAbove._stencilCounter;\n            this._scissorCounter = maskAbove._scissorCounter;\n            this._scissorRect = maskAbove._scissorRect;\n        }\n        else\n        {\n            this._stencilCounter = 0;\n            this._scissorCounter = 0;\n            this._scissorRect = null;\n        }\n    }\n}\n"],"names":["MASK_TYPES","Filter"],"mappings":";;AAwBO,MAAM,SACb;AAAA;AAAA;AAAA;AAAA;AAAA,EA8FI,YAAY,aAA0B,MACtC;AACS,SAAA,OAAOA,qBAAW,MACvB,KAAK,aAAa,IAClB,KAAK,aAAa,cAAc,MAChC,KAAK,SAAS,IACd,KAAK,aAAa,IAClB,KAAK,aAAa,MAClB,KAAK,cAAcC,OAAAA,OAAO,oBAC1B,KAAK,UAAU,IACf,KAAK,YAAY,IACjB,KAAK,WAAW,MAChB,KAAK,kBAAkB,GACvB,KAAK,kBAAkB,GACvB,KAAK,eAAe,MACpB,KAAK,oBAAoB,MACzB,KAAK,aAAa,IAClB,KAAK,UAAU;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,SACJ;AACI,WAAO,KAAK,WAAW,KAAK,SAAS,CAAC,IAAI;AAAA,EAC9C;AAAA,EAEA,IAAI,OAAO,OACX;AACQ,YAEI,KAAK,WAEL,KAAK,SAAS,CAAC,IAAI,QAInB,KAAK,WAAW,CAAC,KAAK,IAK1B,KAAK,WAAW;AAAA,EAExB;AAAA;AAAA,EAGA,QACA;AACQ,SAAK,WAEL,KAAK,aAAa,MAElB,KAAK,OAAOD,UAAAA,WAAW,MAEvB,KAAK,aAAa,KAGtB,KAAK,UAAU,MACf,KAAK,oBAAoB;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,oBAAoB,WACpB;AACQ,iBAEA,KAAK,kBAAkB,UAAU,iBACjC,KAAK,kBAAkB,UAAU,iBACjC,KAAK,eAAe,UAAU,iBAI9B,KAAK,kBAAkB,GACvB,KAAK,kBAAkB,GACvB,KAAK,eAAe;AAAA,EAE5B;AACJ;;"}