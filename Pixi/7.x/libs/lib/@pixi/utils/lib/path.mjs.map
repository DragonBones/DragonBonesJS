{"version":3,"file":"path.mjs","sources":["../src/path.ts"],"sourcesContent":["import { settings } from '@pixi/settings';\n\nfunction assertPath(path: string)\n{\n    if (typeof path !== 'string')\n    {\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\n    }\n}\n\nfunction removeUrlParams(url: string): string\n{\n    const re = url.split('?')[0];\n\n    return re.split('#')[0];\n}\n\nfunction escapeRegExp(string: string)\n{\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction replaceAll(str: string, find: string, replace: string)\n{\n    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean)\n{\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n\n    for (let i = 0; i <= path.length; ++i)\n    {\n        if (i < path.length)\n        {\n            code = path.charCodeAt(i);\n        }\n        else if (code === 47)\n        {\n            break;\n        }\n        else\n        {\n            code = 47;\n        }\n        if (code === 47)\n        {\n            if (lastSlash === i - 1 || dots === 1)\n            {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2)\n            {\n                if (\n                    res.length < 2\n                    || lastSegmentLength !== 2\n                    || res.charCodeAt(res.length - 1) !== 46\n                    || res.charCodeAt(res.length - 2) !== 46\n                )\n                {\n                    if (res.length > 2)\n                    {\n                        const lastSlashIndex = res.lastIndexOf('/');\n\n                        if (lastSlashIndex !== res.length - 1)\n                        {\n                            if (lastSlashIndex === -1)\n                            {\n                                res = '';\n                                lastSegmentLength = 0;\n                            }\n                            else\n                            {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1)\n                    {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot)\n                {\n                    if (res.length > 0)\n                    { res += '/..'; }\n                    else\n                    { res = '..'; }\n                    lastSegmentLength = 2;\n                }\n            }\n            else\n            {\n                if (res.length > 0)\n                {\n                    res += `/${path.slice(lastSlash + 1, i)}`;\n                }\n                else\n                {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === 46 && dots !== -1)\n        {\n            ++dots;\n        }\n        else\n        {\n            dots = -1;\n        }\n    }\n\n    return res;\n}\n\nexport interface Path\n{\n    toPosix: (path: string) => string;\n    toAbsolute: (url: string, baseUrl?: string, rootUrl?: string) => string;\n    isUrl: (path: string) => boolean;\n    isDataUrl: (path: string) => boolean;\n    isBlobUrl: (path: string) => boolean;\n    hasProtocol: (path: string) => boolean;\n    getProtocol: (path: string) => string;\n    normalize: (path: string) => string;\n    join: (...paths: string[]) => string;\n    isAbsolute: (path: string) => boolean;\n    dirname: (path: string) => string;\n    rootname: (path: string) => string;\n    basename: (path: string, ext?: string) => string;\n    extname: (path: string) => string;\n    parse: (path: string) => { root?: string, dir?: string, base?: string, ext?: string, name?: string };\n    sep: string,\n    delimiter: string,\n    joinExtensions: string[],\n}\n\nexport const path: Path = {\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix(path: string) { return replaceAll(path, '\\\\', '/'); },\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl(path: string) { return (/^https?:/).test(this.toPosix(path)); },\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl(path: string)\n    {\n        // eslint-disable-next-line max-len\n        return (/^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i)\n            .test(path);\n    },\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl(path: string)\n    {\n        // Not necessary to have an exact regex to match the blob URLs\n        return path.startsWith('blob:');\n    },\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol(path: string) { return (/^[^/:]+:/).test(this.toPosix(path)); },\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        const matchFile = (/^file:\\/\\/\\//).exec(path);\n\n        if (matchFile)\n        {\n            return matchFile[0];\n        }\n\n        const matchProtocol = (/^[^/:]+:\\/{0,2}/).exec(path);\n\n        if (matchProtocol)\n        {\n            return matchProtocol[0];\n        }\n\n        return '';\n    },\n\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     */\n    toAbsolute(url: string, customBaseUrl?: string, customRootUrl?: string)\n    {\n        assertPath(url);\n\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n\n        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.ADAPTER.getBaseUrl()));\n        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n\n        url = this.toPosix(url);\n\n        // root relative url\n        if (url.startsWith('/'))\n        {\n            return path.join(rootUrl, url.slice(1));\n        }\n\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n\n        return absolutePath;\n    },\n\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize(path: string)\n    {\n        assertPath(path);\n\n        if (path.length === 0) return '.';\n        if (this.isDataUrl(path) || this.isBlobUrl(path)) return path;\n\n        path = this.toPosix(path);\n\n        let protocol = '';\n        const isAbsolute = path.startsWith('/');\n\n        if (this.hasProtocol(path))\n        {\n            protocol = this.rootname(path);\n            path = path.slice(protocol.length);\n        }\n\n        const trailingSeparator = path.endsWith('/');\n\n        // Normalize the path\n        path = normalizeStringPosix(path, false);\n\n        if (path.length > 0 && trailingSeparator) path += '/';\n        if (isAbsolute) return `/${path}`;\n\n        return protocol + path;\n    },\n\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        if (this.hasProtocol(path)) return true;\n\n        return path.startsWith('/');\n    },\n\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     */\n    join(...segments: string[])\n    {\n        if (segments.length === 0)\n        { return '.'; }\n        let joined;\n\n        for (let i = 0; i < segments.length; ++i)\n        {\n            const arg = segments[i];\n\n            assertPath(arg);\n            if (arg.length > 0)\n            {\n                if (joined === undefined) joined = arg;\n                else\n                {\n                    const prevArg = segments[i - 1] ?? '';\n\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase()))\n                    {\n                        joined += `/../${arg}`;\n                    }\n                    else\n                    {\n                        joined += `/${arg}`;\n                    }\n                }\n            }\n        }\n        if (joined === undefined) { return '.'; }\n\n        return this.normalize(joined);\n    },\n\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname(path: string)\n    {\n        assertPath(path);\n        if (path.length === 0) return '.';\n        path = this.toPosix(path);\n        let code = path.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n\n        const proto = this.getProtocol(path);\n        const origpath = path;\n\n        path = path.slice(proto.length);\n\n        for (let i = path.length - 1; i >= 1; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                if (!matchedSlash)\n                {\n                    end = i;\n                    break;\n                }\n            }\n            else\n            {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n\n        // if end is -1 and its a url then we need to add the path back\n        // eslint-disable-next-line no-nested-ternary\n        if (end === -1) return hasRoot ? '/' : this.isUrl(origpath) ? proto + path : proto;\n        if (hasRoot && end === 1) return '//';\n\n        return proto + path.slice(0, end);\n    },\n\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let root = '';\n\n        if (path.startsWith('/')) root = '/';\n        else\n        {\n            root = this.getProtocol(path);\n        }\n\n        if (this.isUrl(path))\n        {\n            // need to find the first path separator\n            const index = path.indexOf('/', root.length);\n\n            if (index !== -1)\n            {\n                root = path.slice(0, index);\n            }\n            else root = path;\n\n            if (!root.endsWith('/')) root += '/';\n        }\n\n        return root;\n    },\n\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename(path: string, ext?: string)\n    {\n        assertPath(path);\n        if (ext) assertPath(ext);\n\n        path = removeUrlParams(this.toPosix(path));\n\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i: number;\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length)\n        {\n            if (ext.length === path.length && ext === path) return '';\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n\n            for (i = path.length - 1; i >= 0; --i)\n            {\n                const code = path.charCodeAt(i);\n\n                if (code === 47)\n                {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash)\n                    {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else\n                {\n                    if (firstNonSlashEnd === -1)\n                    {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0)\n                    {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx))\n                        {\n                            if (--extIdx === -1)\n                            {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else\n                        {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length;\n\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i)\n        {\n            if (path.charCodeAt(i) === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n\n        if (end === -1) return '';\n\n        return path.slice(start, end);\n    },\n\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname(path: string)\n    {\n        assertPath(path);\n        path = removeUrlParams(this.toPosix(path));\n\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        for (let i = path.length - 1; i >= 0; --i)\n        {\n            const code = path.charCodeAt(i);\n\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            return '';\n        }\n\n        return path.slice(startDot, end);\n    },\n\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse(path: string)\n    {\n        assertPath(path);\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n        if (path.length === 0) return ret;\n        path = removeUrlParams(this.toPosix(path));\n\n        let code = path.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path);\n        let start: number;\n        const protocol = '';\n\n        ret.root = this.rootname(path);\n\n        if (isAbsolute || this.hasProtocol(path))\n        {\n            start = 1;\n        }\n        else\n        {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        // Get non-dir info\n        for (; i >= start; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            if (end !== -1)\n            {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);\n                else ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        else\n        {\n            if (startPart === 0 && isAbsolute)\n            {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            }\n            else\n            {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n\n        ret.dir = this.dirname(path);\n        if (protocol) ret.dir = protocol + ret.dir;\n\n        return ret;\n    },\n\n    sep: '/',\n    delimiter: ':',\n    joinExtensions: ['.html'],\n} as Path;\n"],"names":["path"],"mappings":"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"}