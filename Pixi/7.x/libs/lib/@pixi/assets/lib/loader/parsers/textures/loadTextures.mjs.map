{"version":3,"file":"loadTextures.mjs","sources":["../../../../src/loader/parsers/textures/loadTextures.ts"],"sourcesContent":["import { BaseTexture, extensions, ExtensionType, settings, utils } from '@pixi/core';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { WorkerManager } from '../WorkerManager';\nimport { createTexture } from './utils/createTexture';\n\nimport type { IBaseTextureOptions, Texture } from '@pixi/core';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImageExtensions = ['.jpeg', '.jpg', '.png', '.webp', '.avif'];\nconst validImageMIMEs = [\n    'image/jpeg',\n    'image/png',\n    'image/webp',\n    'image/avif',\n];\n\n/**\n * Configuration for the `loadTextures` loader plugin.\n * @memberof PIXI\n * @see PIXI.loadTextures\n */\nexport interface LoadTextureConfig\n{\n    /**\n     * When set to `true`, loading and decoding images will happen with Worker thread,\n     * if available on the browser. This is much more performant as network requests\n     * and decoding can be expensive on the CPU. However, not all environments support\n     * Workers, in some cases it can be helpful to disable by setting to `false`.\n     * @default true\n     */\n    preferWorkers: boolean;\n    /**\n     * When set to `true`, loading and decoding images will happen with `createImageBitmap`,\n     * otherwise it will use `new Image()`.\n     * @default true\n     */\n    preferCreateImageBitmap: boolean;\n    /**\n     * The crossOrigin value to use for images when `preferCreateImageBitmap` is `false`.\n     * @default 'anonymous'\n     */\n    crossOrigin: HTMLImageElement['crossOrigin'];\n}\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n */\nexport async function loadImageBitmap(url: string): Promise<ImageBitmap>\n{\n    const response = await settings.ADAPTER.fetch(url);\n\n    if (!response.ok)\n    {\n        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: `\n            + `${response.status} ${response.statusText}`);\n    }\n\n    const imageBlob = await response.blob();\n    const imageBitmap = await createImageBitmap(imageBlob);\n\n    return imageBitmap;\n}\n\n/**\n * Loads our textures!\n * this makes use of imageBitmaps where available.\n * We load the ImageBitmap on a different thread using the WorkerManager\n * We can then use the ImageBitmap as a source for a Pixi Texture\n *\n * You can customize the behavior of this loader by setting the `config` property.\n * ```js\n * // Set the config\n * import { loadTextures } from '@pixi/assets';\n * loadTextures.config = {\n *    // If true we will use a worker to load the ImageBitmap\n *    preferWorkers: true,\n *    // If false we will use new Image() instead of createImageBitmap\n *    // If false then this will also disable the use of workers as it requires createImageBitmap\n *    preferCreateImageBitmap: true,\n *    crossOrigin: 'anonymous',\n * };\n * ```\n * @memberof PIXI\n */\nexport const loadTextures = {\n\n    name: 'loadTextures',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n    },\n\n    config: {\n        preferWorkers: true,\n        preferCreateImageBitmap: true,\n        crossOrigin: 'anonymous',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n    },\n\n    async load(url: string, asset: ResolvedAsset<IBaseTextureOptions>, loader: Loader): Promise<Texture>\n    {\n        const useImageBitmap = globalThis.createImageBitmap && this.config.preferCreateImageBitmap;\n        let src: HTMLImageElement | ImageBitmap;\n\n        if (useImageBitmap)\n        {\n            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported())\n            {\n                src = await WorkerManager.loadImageBitmap(url);\n            }\n            else\n            {\n                src = await loadImageBitmap(url);\n            }\n        }\n        else\n        {\n            src = await new Promise((resolve, reject) =>\n            {\n                const src = new Image();\n\n                src.crossOrigin = this.config.crossOrigin;\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = () => resolve(src);\n                    src.onerror = (e) => reject(e);\n                }\n            });\n        }\n\n        const options = { ...asset.data };\n\n        options.resolution ??= utils.getResolutionOfUrl(url);\n        if (useImageBitmap && options.resourceOptions?.ownsImageBitmap === undefined)\n        {\n            options.resourceOptions = { ...options.resourceOptions };\n            options.resourceOptions.ownsImageBitmap = true;\n        }\n\n        const base = new BaseTexture(src, options);\n\n        base.resource.src = url;\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} as LoaderParser<Texture, IBaseTextureOptions, LoadTextureConfig>;\n\nextensions.add(loadTextures);\n"],"names":["src"],"mappings":";;;;;;AAYA,MAAM,uBAAuB,CAAC,SAAS,QAAQ,QAAQ,SAAS,OAAO,GACjE,kBAAkB;AAAA,EACpB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AAoCA,eAAsB,gBAAgB,KACtC;AACI,QAAM,WAAW,MAAM,SAAS,QAAQ,MAAM,GAAG;AAEjD,MAAI,CAAC,SAAS;AAEJ,UAAA,IAAI,MAAM,qCAAqC,GAAG,KAC/C,SAAS,MAAM,IAAI,SAAS,UAAU,EAAE;AAG/C,QAAA,YAAY,MAAM,SAAS;AACb,SAAA,MAAM,kBAAkB,SAAS;AAGzD;AAuBO,MAAM,eAAe;AAAA,EAExB,MAAM;AAAA,EAEN,WAAW;AAAA,IACP,MAAM,cAAc;AAAA,IACpB,UAAU,qBAAqB;AAAA,EACnC;AAAA,EAEA,QAAQ;AAAA,IACJ,eAAe;AAAA,IACf,yBAAyB;AAAA,IACzB,aAAa;AAAA,EACjB;AAAA,EAEA,KAAK,KACL;AACI,WAAO,aAAa,KAAK,eAAe,KAAK,eAAe,KAAK,oBAAoB;AAAA,EACzF;AAAA,EAEA,MAAM,KAAK,KAAa,OAA2C,QACnE;AACI,UAAM,iBAAiB,WAAW,qBAAqB,KAAK,OAAO;AAC/D,QAAA;AAEA,qBAEI,KAAK,OAAO,iBAAiB,MAAM,cAAc,2BAEjD,MAAM,MAAM,cAAc,gBAAgB,GAAG,IAI7C,MAAM,MAAM,gBAAgB,GAAG,IAKnC,MAAM,MAAM,IAAI,QAAQ,CAAC,SAAS,WAClC;AACUA,YAAAA,OAAM,IAAI;AAEhBA,WAAI,cAAc,KAAK,OAAO,aAC9BA,KAAI,MAAM,KACNA,KAAI,WAEJ,QAAQA,IAAG,KAIXA,KAAI,SAAS,MAAM,QAAQA,IAAG,GAC9BA,KAAI,UAAU,CAAC,MAAM,OAAO,CAAC;AAAA,IAAA,CAEpC;AAGL,UAAM,UAAU,EAAE,GAAG,MAAM,KAAK;AAExB,YAAA,eAAR,QAAQ,aAAe,MAAM,mBAAmB,GAAG,IAC/C,kBAAkB,QAAQ,iBAAiB,oBAAoB,WAE/D,QAAQ,kBAAkB,EAAE,GAAG,QAAQ,mBACvC,QAAQ,gBAAgB,kBAAkB;AAG9C,UAAM,OAAO,IAAI,YAAY,KAAK,OAAO;AAEzC,WAAA,KAAK,SAAS,MAAM,KAEb,cAAc,MAAM,QAAQ,GAAG;AAAA,EAC1C;AAAA,EAEA,OAAO,SACP;AACI,YAAQ,QAAQ,EAAI;AAAA,EACxB;AACJ;AAEA,WAAW,IAAI,YAAY;"}