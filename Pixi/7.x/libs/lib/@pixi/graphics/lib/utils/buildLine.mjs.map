{"version":3,"file":"buildLine.mjs","sources":["../../src/utils/buildLine.ts"],"sourcesContent":["import { Point, SHAPES } from '@pixi/core';\nimport { curves, LINE_CAP, LINE_JOIN } from '../const';\n\nimport type { Polygon } from '@pixi/core';\nimport type { GraphicsData } from '../GraphicsData';\nimport type { GraphicsGeometry } from '../GraphicsGeometry';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(\n        eix, eiy,\n        eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: Array<number>,\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n    {\n        const r1x = cx - nxtPx;\n        const r1y = cy - nxtPy;\n\n        if (r1x === 0)\n        {\n            if (r1y > 0)\n            {\n                angleDiff = -angleDiff;\n            }\n        }\n        else if (r1x >= -curves.epsilon)\n        {\n            angleDiff = -angleDiff;\n        }\n    }*/\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(\n            cx, cy,\n            sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(\n                cx, cy,\n                cx + ((Math.sin(angle) * radius)), cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(\n            cx, cy,\n            ex, ey);\n    }\n    else\n    {\n        verts.push(\n            sx, sy,\n            cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(\n                cx + ((Math.sin(angle) * radius)), cy + ((Math.cos(angle) * radius)),\n                cx, cy);\n        }\n\n        verts.push(\n            ex, ey,\n            cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    const shape = graphicsData.shape as Polygon;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    const style = graphicsData.lineStyle;\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpx = -(y0 - y1);\n    let perpy = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x0 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpx * innerWeight),\n                y0 - (perpy * innerWeight),\n                x0 + (perpx * outerWeight),\n                y0 + (perpy * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpx * innerWeight), y0 - (perpy * innerWeight),\n        x0 + (perpx * outerWeight), y0 + (perpy * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpx = -(y0 - y1);\n        perpy = x0 - x1;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === LINE_JOIN.ROUND)\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight), y1 - (perp1y * outerWeight),\n                    x1 + (perp1x * innerWeight), y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n        const c1 = ((-perpx + x0) * (-perpy + y1)) - ((-perpx + x1) * (-perpy + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pdist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pdist <= smallerInsideDiagonalSq;\n\n        let join = style.join;\n\n        if (join === LINE_JOIN.MITER && pdist / widthSquared > miterLimitSquared)\n        {\n            join = LINE_JOIN.BEVEL;\n        }\n\n        if (insideMiterOk)\n        {\n            switch (join)\n            {\n                case LINE_JOIN.MITER:\n                {\n                    verts.push(\n                        imx, imy,\n                        omx, omy);\n                    break;\n                }\n                case LINE_JOIN.BEVEL:\n                {\n                    if (clockwise) /* rotating at inner angle */\n                    {\n                        verts.push(\n                            imx, imy, // inner miter point\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight), // first segment's outer vertex\n                            imx, imy, // inner miter point\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                    }\n                    else /* rotating at outer angle */\n                    {\n                        verts.push(\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight), // first segment's inner vertex\n                            omx, omy, // outer miter point\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight), // second segment's outer vertex\n                            omx, omy); // outer miter point\n                    }\n\n                    indexCount += 2;\n                    break;\n                }\n                case LINE_JOIN.ROUND:\n                {\n                    if (clockwise) /* arc is outside */\n                    {\n                        verts.push(\n                            imx, imy,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n                        indexCount += round(\n                            x1, y1,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                            verts, true\n                        ) + 4;\n\n                        verts.push(\n                            imx, imy,\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                    }\n                    else /* arc is inside */\n                    {\n                        verts.push(\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            omx, omy);\n\n                        indexCount += round(\n                            x1, y1,\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            verts, false\n                        ) + 4;\n\n                        verts.push(\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            omx, omy);\n                    }\n                    break;\n                }\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(\n                x1 - (perpx * innerWeight), y1 - (perpy * innerWeight), // first segment's inner vertex\n                x1 + (perpx * outerWeight), y1 + (perpy * outerWeight)); // first segment's outer vertex\n            switch (join)\n            {\n                case LINE_JOIN.MITER:\n                {\n                    if (clockwise)\n                    {\n                        verts.push(\n                            omx, omy, // inner miter point\n                            omx, omy); // inner miter point\n                    }\n                    else\n                    {\n                        verts.push(\n                            imx, imy, // outer miter point\n                            imx, imy); // outer miter point\n                    }\n                    indexCount += 2;\n                    break;\n                }\n                case LINE_JOIN.ROUND:\n                {\n                    if (clockwise) /* arc is outside */\n                    {\n                        indexCount += round(\n                            x1, y1,\n                            x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                            x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                            verts, true\n                        ) + 2;\n                    }\n                    else /* arc is inside */\n                    {\n                        indexCount += round(\n                            x1, y1,\n                            x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                            x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                            verts, false\n                        ) + 2;\n                    }\n                    break;\n                }\n            }\n            verts.push(\n                x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight), // second segment's inner vertex\n                x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(\n        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x1 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    const indices = graphicsGeometry.indices;\n    const eps2 = curves.epsilon * curves.epsilon;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    let i = 0;\n\n    const shape = graphicsData.shape as Polygon;\n    const points = graphicsData.points || shape.points;\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n    if (points.length === 0) return;\n\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    const length = points.length / 2;\n\n    const startIndex = verts.length / 2;\n    let currentIndex = startIndex;\n\n    verts.push(points[0], points[1]);\n\n    for (i = 1; i < length; i++)\n    {\n        verts.push(points[i * 2], points[(i * 2) + 1]);\n        indices.push(currentIndex, currentIndex + 1);\n\n        currentIndex++;\n    }\n\n    if (closedShape)\n    {\n        indices.push(currentIndex, startIndex);\n    }\n}\n\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nexport function buildLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    if (graphicsData.lineStyle.native)\n    {\n        buildNativeLine(graphicsData, graphicsGeometry);\n    }\n    else\n    {\n        buildNonNativeLine(graphicsData, graphicsGeometry);\n    }\n}\n"],"names":[],"mappings":"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"}