{"version":3,"file":"detectCompressedTextures.js","sources":["../../src/loaders/detectCompressedTextures.ts"],"sourcesContent":["import { extensions as ext, ExtensionType, settings } from '@pixi/core';\n\nimport type { FormatDetectionParser } from '@pixi/assets';\nimport type { CompressedTextureExtensionRef, CompressedTextureExtensions } from './compressedTextureExtensions';\n\nlet storedGl: WebGLRenderingContext;\nlet extensions: Partial<CompressedTextureExtensions>;\n\nfunction getCompressedTextureExtensions()\n{\n    extensions = {\n        bptc: storedGl.getExtension('EXT_texture_compression_bptc'),\n        astc: storedGl.getExtension('WEBGL_compressed_texture_astc'),\n        etc: storedGl.getExtension('WEBGL_compressed_texture_etc'),\n        s3tc: storedGl.getExtension('WEBGL_compressed_texture_s3tc'),\n        s3tc_sRGB: storedGl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), /* eslint-disable-line camelcase */\n        pvrtc: storedGl.getExtension('WEBGL_compressed_texture_pvrtc')\n            || storedGl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n        etc1: storedGl.getExtension('WEBGL_compressed_texture_etc1'),\n        atc: storedGl.getExtension('WEBGL_compressed_texture_atc'),\n    } as Partial<CompressedTextureExtensions>;\n}\n\nexport const detectCompressedTextures = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 2,\n    },\n    test: async (): Promise<boolean> =>\n    {\n        // Auto-detect WebGL compressed-texture extensions\n        const canvas = settings.ADAPTER.createCanvas();\n        const gl = canvas.getContext('webgl');\n\n        if (!gl)\n        {\n            if (process.env.DEBUG)\n            {\n                console.warn('WebGL not available for compressed textures.');\n            }\n\n            return false;\n        }\n\n        storedGl = gl;\n\n        return true;\n    },\n    add: async (formats: string[]): Promise<string[]> =>\n    {\n        if (!extensions) getCompressedTextureExtensions();\n\n        const textureFormats = [];\n\n        // Assign all available compressed-texture formats\n        for (const extensionName in extensions)\n        {\n            const extension = extensions[extensionName as CompressedTextureExtensionRef];\n\n            if (!extension)\n            {\n                continue;\n            }\n\n            textureFormats.push(extensionName);\n        }\n\n        return [...textureFormats, ...formats];\n    },\n    remove: async (formats: string[]): Promise<string[]> =>\n    {\n        if (!extensions) getCompressedTextureExtensions();\n\n        return formats.filter((f) => !(f in extensions));\n    },\n} as FormatDetectionParser;\n\next.add(detectCompressedTextures);\n"],"names":["ExtensionType","settings","ext"],"mappings":";;AAKA,IAAI,UACA;AAEJ,SAAS,iCACT;AACiB,eAAA;AAAA,IACT,MAAM,SAAS,aAAa,8BAA8B;AAAA,IAC1D,MAAM,SAAS,aAAa,+BAA+B;AAAA,IAC3D,KAAK,SAAS,aAAa,8BAA8B;AAAA,IACzD,MAAM,SAAS,aAAa,+BAA+B;AAAA,IAC3D,WAAW,SAAS,aAAa,oCAAoC;AAAA;AAAA,IACrE,OAAO,SAAS,aAAa,gCAAgC,KACtD,SAAS,aAAa,uCAAuC;AAAA,IACpE,MAAM,SAAS,aAAa,+BAA+B;AAAA,IAC3D,KAAK,SAAS,aAAa,8BAA8B;AAAA,EAAA;AAEjE;AAEO,MAAM,2BAA2B;AAAA,EACpC,WAAW;AAAA,IACP,MAAMA,KAAc,cAAA;AAAA,IACpB,UAAU;AAAA,EACd;AAAA,EACA,MAAM,YACN;AAGI,UAAM,KADSC,KAAAA,SAAS,QAAQ,aAAa,EAC3B,WAAW,OAAO;AAEpC,WAAK,MAUL,WAAW,IAEJ,OARC,QAAQ,KAAK,8CAA8C,GAGxD;AAAA,EAMf;AAAA,EACA,KAAK,OAAO,YACZ;AACS,kBAAY,+BAA+B;AAEhD,UAAM,iBAAiB,CAAA;AAGvB,eAAW,iBAAiB;AAEN,iBAAW,aAA8C,KAO3E,eAAe,KAAK,aAAa;AAGrC,WAAO,CAAC,GAAG,gBAAgB,GAAG,OAAO;AAAA,EACzC;AAAA,EACA,QAAQ,OAAO,aAEN,cAAY,+BAA+B,GAEzC,QAAQ,OAAO,CAAC,MAAM,EAAE,KAAK,WAAW;AAEvD;AAEAC,KAAAA,WAAI,IAAI,wBAAwB;;"}